{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\gaspa\\\\OneDrive\\\\Documents\\\\MMI 2\\\\S4\\\\React\\\\SpinningWheel\\\\spin-wheel\\\\src\\\\components\\\\WheelConstructor.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState, useRef } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WheelComponent = ({\n  segments,\n  segColors,\n  winningSegment,\n  onFinished,\n  primaryColor = \"black\",\n  contrastColor = \"white\",\n  buttonText = \"Spin\",\n  isOnlyOnce = true,\n  size = window.innerWidth,\n  upDuration = 100,\n  downDuration = 1000,\n  fontFamily = \"proxima-nova\"\n}) => {\n  _s();\n  const randomString = () => {\n    const chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\".split(\"\");\n    const length = 8;\n    let str = \"\";\n    for (let i = 0; i < length; i++) {\n      str += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return str;\n  };\n  const canvasId = useRef(`canvas-${randomString()}`);\n  const wheelId = useRef(`wheel-${randomString()}`);\n  const dimension = (size + 20) * 2;\n  let currentSegment = \"\";\n  let isStarted = false;\n  const [isFinished, setFinished] = useState(false);\n  let timerHandle = 0;\n  const timerDelay = segments.length;\n  let angleCurrent = 0;\n  let angleDelta = 0;\n  let canvasContext = null;\n  let maxSpeed = Math.PI / segments.length;\n  const upTime = segments.length * upDuration;\n  const downTime = segments.length * downDuration;\n  let spinStart = 0;\n  let frames = 0;\n  const centerX = size + 20;\n  const centerY = size + 20;\n  useEffect(() => {\n    wheelInit();\n    setTimeout(() => {\n      window.scrollTo(0, 1);\n    }, 0);\n  }, []);\n  const wheelInit = () => {\n    initCanvas();\n    wheelDraw();\n  };\n  const initCanvas = () => {\n    let canvas = document.getElementById(canvasId.current);\n    if (!canvas) {\n      var _document$getElementB;\n      canvas = document.createElement(\"canvas\");\n      canvas.setAttribute(\"id\", canvasId.current);\n      (_document$getElementB = document.getElementById(wheelId.current)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.appendChild(canvas);\n    }\n    canvas.width = dimension;\n    canvas.height = dimension;\n    canvas.addEventListener(\"click\", spin, false);\n    canvasContext = canvas.getContext(\"2d\");\n\n    // Set canvas resolution to match device pixel ratio\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const backingStoreRatio = canvasContext.webkitBackingStorePixelRatio || canvasContext.mozBackingStorePixelRatio || canvasContext.msBackingStorePixelRatio || canvasContext.oBackingStorePixelRatio || canvasContext.backingStorePixelRatio || 1;\n    const ratio = devicePixelRatio / backingStoreRatio;\n    if (devicePixelRatio !== backingStoreRatio) {\n      const oldWidth = canvas.width;\n      const oldHeight = canvas.height;\n      canvas.width = oldWidth * ratio;\n      canvas.height = oldHeight * ratio;\n      canvas.style.width = oldWidth + 'px';\n      canvas.style.height = oldHeight + 'px';\n      canvasContext.scale(ratio, ratio);\n    }\n  };\n  const spin = () => {\n    isStarted = true;\n    if (timerHandle === 0) {\n      spinStart = new Date().getTime();\n      maxSpeed = Math.PI / segments.length;\n      frames = 0;\n      timerHandle = setInterval(onTimerTick, timerDelay);\n    }\n  };\n  const onTimerTick = () => {\n    frames++;\n    draw();\n    const duration = new Date().getTime() - spinStart;\n    let progress = 0;\n    let finished = false;\n    if (duration < upTime) {\n      progress = duration / upTime;\n      angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2);\n    } else {\n      if (winningSegment) {\n        if (currentSegment === winningSegment && frames > segments.length) {\n          progress = duration / upTime;\n          angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n          progress = 1;\n        } else {\n          progress = duration / downTime;\n          angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n        }\n      } else {\n        progress = duration / downTime;\n        angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n      }\n      if (progress >= 1) finished = true;\n    }\n    angleCurrent += angleDelta;\n    while (angleCurrent >= Math.PI * 2) angleCurrent -= Math.PI * 2;\n    if (finished) {\n      setFinished(true);\n      onFinished(currentSegment);\n      clearInterval(timerHandle);\n      timerHandle = 0;\n      angleDelta = 0;\n    }\n  };\n  const wheelDraw = () => {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n  const draw = () => {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n  const drawSegment = (key, lastAngle, angle) => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    const value = segments[key];\n    ctx.save();\n    ctx.beginPath();\n    ctx.moveTo(centerX, centerY);\n    ctx.arc(centerX, centerY, size, lastAngle, angle, false);\n    ctx.lineTo(centerX, centerY);\n    ctx.closePath();\n    ctx.fillStyle = segColors[key];\n    ctx.fill();\n    ctx.stroke();\n    ctx.save();\n    ctx.translate(centerX, centerY);\n    ctx.rotate((lastAngle + angle) / 2);\n    ctx.fillStyle = contrastColor;\n    ctx.font = \"bold 1em \" + fontFamily;\n    ctx.fillText(value.substr(0, 21), size / 2 + 20, 0);\n    ctx.restore();\n  };\n  const drawWheel = () => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    let lastAngle = angleCurrent;\n    const len = segments.length;\n    const PI2 = Math.PI * 2;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = primaryColor;\n    ctx.textBaseline = \"middle\";\n    ctx.textAlign = \"center\";\n    ctx.font = \"1em \" + fontFamily;\n    for (let i = 1; i <= len; i++) {\n      const angle = PI2 * (i / len) + angleCurrent;\n      drawSegment(i - 1, lastAngle, angle);\n      lastAngle = angle;\n    }\n\n    // Draw a center circle\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, 30, 0, PI2, false);\n    ctx.closePath();\n    ctx.fillStyle = primaryColor;\n    ctx.lineWidth = 5;\n    ctx.strokeStyle = contrastColor;\n    ctx.fill();\n    ctx.font = \"bold 1em \" + fontFamily;\n    ctx.fillStyle = contrastColor;\n    ctx.textAlign = \"center\";\n    ctx.fillText(buttonText, centerX, centerY + 3);\n    ctx.stroke();\n\n    // Draw outer circle\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, size, 0, PI2, false);\n    ctx.closePath();\n    ctx.lineWidth = 5;\n    ctx.strokeStyle = primaryColor;\n    ctx.stroke();\n  };\n  const drawNeedle = () => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = contrastColor;\n    ctx.fillStyle = contrastColor;\n    ctx.beginPath();\n    ctx.moveTo(centerX + 20, centerY - 20);\n    ctx.lineTo(centerX - 20, centerY - 20);\n    ctx.lineTo(centerX, centerY - 100);\n    ctx.closePath();\n    ctx.fill();\n    const change = angleCurrent + Math.PI / 2;\n    let i = segments.length - Math.floor(change / (Math.PI * 2) * segments.length) - 1;\n    if (i < 0) i = i + segments.length;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillStyle = primaryColor;\n    ctx.font = \"bold 1.5em \" + fontFamily;\n    currentSegment = segments[i];\n  };\n  const clear = () => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    ctx.clearRect(0, 0, dimension, dimension);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    id: wheelId.current,\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      id: canvasId.current,\n      width: dimension,\n      height: dimension,\n      style: {\n        pointerEvents: isFinished && isOnlyOnce ? \"none\" : \"auto\"\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 254,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 253,\n    columnNumber: 5\n  }, this);\n};\n_s(WheelComponent, \"R43FBdw/DOTsz5Oe2umAcDTPoI0=\");\n_c = WheelComponent;\nexport default WheelComponent;\nvar _c;\n$RefreshReg$(_c, \"WheelComponent\");","map":{"version":3,"names":["React","useEffect","useState","useRef","jsxDEV","_jsxDEV","WheelComponent","segments","segColors","winningSegment","onFinished","primaryColor","contrastColor","buttonText","isOnlyOnce","size","window","innerWidth","upDuration","downDuration","fontFamily","_s","randomString","chars","split","length","str","i","Math","floor","random","canvasId","wheelId","dimension","currentSegment","isStarted","isFinished","setFinished","timerHandle","timerDelay","angleCurrent","angleDelta","canvasContext","maxSpeed","PI","upTime","downTime","spinStart","frames","centerX","centerY","wheelInit","setTimeout","scrollTo","initCanvas","wheelDraw","canvas","document","getElementById","current","_document$getElementB","createElement","setAttribute","appendChild","width","height","addEventListener","spin","getContext","devicePixelRatio","backingStoreRatio","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","ratio","oldWidth","oldHeight","style","scale","Date","getTime","setInterval","onTimerTick","draw","duration","progress","finished","sin","clearInterval","clear","drawWheel","drawNeedle","drawSegment","key","lastAngle","angle","ctx","value","save","beginPath","moveTo","arc","lineTo","closePath","fillStyle","fill","stroke","translate","rotate","font","fillText","substr","restore","len","PI2","lineWidth","strokeStyle","textBaseline","textAlign","change","clearRect","id","children","pointerEvents","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/gaspa/OneDrive/Documents/MMI 2/S4/React/SpinningWheel/spin-wheel/src/components/WheelConstructor.jsx"],"sourcesContent":["import React, { useEffect, useState, useRef } from \"react\";\n\nconst WheelComponent = ({\n  segments,\n  segColors,\n  winningSegment,\n  onFinished,\n  primaryColor = \"black\",\n  contrastColor = \"white\",\n  buttonText = \"Spin\",\n  isOnlyOnce = true,\n  size = window.innerWidth,\n  upDuration = 100,\n  downDuration = 1000,\n  fontFamily = \"proxima-nova\",\n}) => {\n  const randomString = () => {\n    const chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\".split(\n      \"\"\n    );\n    const length = 8;\n    let str = \"\";\n    for (let i = 0; i < length; i++) {\n      str += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return str;\n  };\n  const canvasId = useRef(`canvas-${randomString()}`);\n  const wheelId = useRef(`wheel-${randomString()}`);\n  const dimension = (size + 20) * 2;\n  let currentSegment = \"\";\n  let isStarted = false;\n  const [isFinished, setFinished] = useState(false);\n  let timerHandle = 0;\n  const timerDelay = segments.length;\n  let angleCurrent = 0;\n  let angleDelta = 0;\n  let canvasContext = null;\n  let maxSpeed = Math.PI / segments.length;\n  const upTime = segments.length * upDuration;\n  const downTime = segments.length * downDuration;\n  let spinStart = 0;\n  let frames = 0;\n  const centerX = size + 20;\n  const centerY = size + 20;\n\n  useEffect(() => {\n    wheelInit();\n    setTimeout(() => {\n      window.scrollTo(0, 1);\n    }, 0);\n  }, []);\n\n  const wheelInit = () => {\n    initCanvas();\n    wheelDraw();\n  };\n\n  const initCanvas = () => {\n    let canvas = document.getElementById(canvasId.current);\n    if (!canvas) {\n      canvas = document.createElement(\"canvas\");\n      canvas.setAttribute(\"id\", canvasId.current);\n      document.getElementById(wheelId.current)?.appendChild(canvas);\n    }\n    canvas.width = dimension;\n    canvas.height = dimension;\n    canvas.addEventListener(\"click\", spin, false);\n    canvasContext = canvas.getContext(\"2d\");\n\n    // Set canvas resolution to match device pixel ratio\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    const backingStoreRatio = canvasContext.webkitBackingStorePixelRatio ||\n                               canvasContext.mozBackingStorePixelRatio ||\n                               canvasContext.msBackingStorePixelRatio ||\n                               canvasContext.oBackingStorePixelRatio ||\n                               canvasContext.backingStorePixelRatio || 1;\n    const ratio = devicePixelRatio / backingStoreRatio;\n    if (devicePixelRatio !== backingStoreRatio) {\n      const oldWidth = canvas.width;\n      const oldHeight = canvas.height;\n      canvas.width = oldWidth * ratio;\n      canvas.height = oldHeight * ratio;\n      canvas.style.width = oldWidth + 'px';\n      canvas.style.height = oldHeight + 'px';\n      canvasContext.scale(ratio, ratio);\n    }\n  };\n\n  const spin = () => {\n    isStarted = true;\n    if (timerHandle === 0) {\n      spinStart = new Date().getTime();\n      maxSpeed = Math.PI / segments.length;\n      frames = 0;\n      timerHandle = setInterval(onTimerTick, timerDelay);\n    }\n  };\n\n  const onTimerTick = () => {\n    frames++;\n    draw();\n    const duration = new Date().getTime() - spinStart;\n    let progress = 0;\n    let finished = false;\n    if (duration < upTime) {\n      progress = duration / upTime;\n      angleDelta = maxSpeed * Math.sin((progress * Math.PI) / 2);\n    } else {\n      if (winningSegment) {\n        if (currentSegment === winningSegment && frames > segments.length) {\n          progress = duration / upTime;\n          angleDelta =\n            maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2);\n          progress = 1;\n        } else {\n          progress = duration / downTime;\n          angleDelta =\n            maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2);\n        }\n      } else {\n        progress = duration / downTime;\n        angleDelta =\n          maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2);\n      }\n      if (progress >= 1) finished = true;\n    }\n\n    angleCurrent += angleDelta;\n    while (angleCurrent >= Math.PI * 2) angleCurrent -= Math.PI * 2;\n    if (finished) {\n      setFinished(true);\n      onFinished(currentSegment);\n      clearInterval(timerHandle);\n      timerHandle = 0;\n      angleDelta = 0;\n    }\n  };\n\n  const wheelDraw = () => {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n\n  const draw = () => {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n\n  const drawSegment = (key, lastAngle, angle) => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    const value = segments[key];\n    ctx.save();\n    ctx.beginPath();\n    ctx.moveTo(centerX, centerY);\n    ctx.arc(centerX, centerY, size, lastAngle, angle, false);\n    ctx.lineTo(centerX, centerY);\n    ctx.closePath();\n    ctx.fillStyle = segColors[key];\n    ctx.fill();\n    ctx.stroke();\n    ctx.save();\n    ctx.translate(centerX, centerY);\n    ctx.rotate((lastAngle + angle) / 2);\n    ctx.fillStyle = contrastColor;\n    ctx.font = \"bold 1em \" + fontFamily;\n    ctx.fillText(value.substr(0, 21), size / 2 + 20, 0);\n    ctx.restore();\n  };\n\n  const drawWheel = () => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    let lastAngle = angleCurrent;\n    const len = segments.length;\n    const PI2 = Math.PI * 2;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = primaryColor;\n    ctx.textBaseline = \"middle\";\n    ctx.textAlign = \"center\";\n    ctx.font = \"1em \" + fontFamily;\n    for (let i = 1; i <= len; i++) {\n      const angle = PI2 * (i / len) + angleCurrent;\n      drawSegment(i - 1, lastAngle, angle);\n      lastAngle = angle;\n    }\n\n    // Draw a center circle\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, 30, 0, PI2, false);\n    ctx.closePath();\n    ctx.fillStyle = primaryColor;\n    ctx.lineWidth = 5;\n    ctx.strokeStyle = contrastColor;\n    ctx.fill();\n    ctx.font = \"bold 1em \" + fontFamily;\n    ctx.fillStyle = contrastColor;\n    ctx.textAlign = \"center\";\n    ctx.fillText(buttonText, centerX, centerY + 3);\n    ctx.stroke();\n\n    // Draw outer circle\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, size, 0, PI2, false);\n    ctx.closePath();\n\n    ctx.lineWidth = 5;\n    ctx.strokeStyle = primaryColor;\n    ctx.stroke();\n  };\n\n  const drawNeedle = () => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = contrastColor;\n    ctx.fillStyle = contrastColor;\n    ctx.beginPath();\n    ctx.moveTo(centerX + 20, centerY - 20);\n    ctx.lineTo(centerX - 20, centerY - 20);\n    ctx.lineTo(centerX, centerY - 100);\n    ctx.closePath();\n    ctx.fill();\n    const change = angleCurrent + Math.PI / 2;\n    let i =\n      segments.length -\n      Math.floor((change / (Math.PI * 2)) * segments.length) -\n      1;\n    if (i < 0) i = i + segments.length;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillStyle = primaryColor;\n    ctx.font = \"bold 1.5em \" + fontFamily;\n    currentSegment = segments[i];\n  };\n  const clear = () => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    ctx.clearRect(0, 0, dimension, dimension);\n  };\n  return (\n    <div id={wheelId.current}>\n      <canvas\n        id={canvasId.current}\n        width={dimension}\n        height={dimension}\n        style={{\n          pointerEvents: isFinished && isOnlyOnce ? \"none\" : \"auto\",\n        }}\n      />\n    </div>\n  );\n};\nexport default WheelComponent;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}