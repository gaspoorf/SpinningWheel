{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\gaspa\\\\OneDrive\\\\Documents\\\\MMI 2\\\\S4\\\\React\\\\SpinningWheel\\\\spin-wheel\\\\src\\\\components\\\\WheelConstructor.jsx\",\n  _s = $RefreshSig$();\nimport { useEffect, useState, useRef } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WheelComponent = ({\n  segments,\n  segColors,\n  winningSegment,\n  onFinished,\n  primaryColor = \"black\",\n  contrastColor = \"white\",\n  buttonText = \"Spin\",\n  isOnlyOnce = true,\n  size = 300,\n  // Utilisation d'une taille fixe\n  upDuration = 100,\n  downDuration = 1000,\n  fontFamily = \"Arial, sans-serif\" // Utilisation d'une police web standard\n}) => {\n  _s();\n  const randomString = () => {\n    const chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\".split(\"\");\n    const length = 8;\n    let str = \"\";\n    for (let i = 0; i < length; i++) {\n      str += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return str;\n  };\n  const canvasId = useRef(`canvas-${randomString()}`);\n  const wheelId = useRef(`wheel-${randomString()}`);\n  const dimension = size; // Utilisation de la taille fixe pour le canvas\n  let currentSegment = \"\";\n  let isStarted = false;\n  const [isFinished, setFinished] = useState(false);\n  let timerHandle = 0;\n  const timerDelay = segments.length;\n  let angleCurrent = 0;\n  let angleDelta = 0;\n  let canvasContext = null;\n  let maxSpeed = Math.PI / segments.length;\n  const upTime = segments.length * upDuration;\n  const downTime = segments.length * downDuration;\n  let spinStart = 0;\n  let frames = 0;\n  const centerX = size / 2;\n  const centerY = size / 2;\n  useEffect(() => {\n    wheelInit();\n    setTimeout(() => {\n      window.scrollTo(0, 1);\n    }, 0);\n  }, []);\n  const wheelInit = () => {\n    initCanvas();\n    wheelDraw();\n  };\n  const initCanvas = () => {\n    var _canvas;\n    let canvas = document.getElementById(canvasId.current);\n    if (navigator.userAgent.indexOf(\"MSIE\") !== -1) {\n      var _document$getElementB;\n      canvas = document.createElement(\"canvas\");\n      canvas.setAttribute(\"width\", `${dimension}`);\n      canvas.setAttribute(\"height\", `${dimension}`);\n      canvas.setAttribute(\"id\", canvasId.current);\n      (_document$getElementB = document.getElementById(wheelId.current)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.appendChild(canvas);\n    }\n    (_canvas = canvas) === null || _canvas === void 0 ? void 0 : _canvas.addEventListener(\"click\", spin, false);\n    canvasContext = canvas.getContext(\"2d\");\n  };\n  const spin = () => {\n    isStarted = true;\n    if (timerHandle === 0) {\n      spinStart = new Date().getTime();\n      maxSpeed = Math.PI / segments.length;\n      frames = 0;\n      timerHandle = setInterval(onTimerTick, timerDelay);\n    }\n  };\n  const onTimerTick = () => {\n    frames++;\n    draw();\n    const duration = new Date().getTime() - spinStart;\n    let progress = 0;\n    let finished = false;\n    if (duration < upTime) {\n      progress = duration / upTime;\n      angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2);\n    } else {\n      if (winningSegment) {\n        if (currentSegment === winningSegment && frames > segments.length) {\n          progress = duration / upTime;\n          angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n          progress = 1;\n        } else {\n          progress = duration / downTime;\n          angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n        }\n      } else {\n        progress = duration / downTime;\n        angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n      }\n      if (progress >= 1) finished = true;\n    }\n    angleCurrent += angleDelta;\n    while (angleCurrent >= Math.PI * 2) angleCurrent -= Math.PI * 2;\n    if (finished) {\n      setFinished(true);\n      onFinished(currentSegment);\n      clearInterval(timerHandle);\n      timerHandle = 0;\n      angleDelta = 0;\n    }\n  };\n  const wheelDraw = () => {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n  const draw = () => {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n  const drawSegment = (key, lastAngle, angle) => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    const value = segments[key];\n    ctx.save();\n    ctx.beginPath();\n    ctx.moveTo(centerX, centerY);\n    ctx.arc(centerX, centerY, size / 2, lastAngle, angle, false);\n    ctx.lineTo(centerX, centerY);\n    ctx.closePath();\n    ctx.fillStyle = segColors[key];\n    ctx.fill();\n    ctx.stroke();\n    ctx.save();\n    ctx.translate(centerX, centerY);\n    ctx.rotate((lastAngle + angle) / 2);\n    ctx.fillStyle = contrastColor;\n    ctx.font = \"bold 1em \" + fontFamily;\n    ctx.fillText(value.substr(0, 21), size / 2 + 20, 0);\n    ctx.restore();\n  };\n  const drawWheel = () => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    let lastAngle = angleCurrent;\n    const len = segments.length;\n    const PI2 = Math.PI * 2;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = primaryColor;\n    ctx.textBaseline = \"middle\";\n    ctx.textAlign = \"center\";\n    ctx.font = \"1em \" + fontFamily;\n    for (let i = 1; i <= len; i++) {\n      const angle = PI2 * (i / len) + angleCurrent;\n      drawSegment(i - 1, lastAngle, angle);\n      lastAngle = angle;\n    }\n\n    // Draw a center circle\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, 50, 0, PI2, false);\n    ctx.closePath();\n    ctx.fillStyle = primaryColor;\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = contrastColor;\n    ctx.fill();\n    ctx.font = \"bold 2em \" + fontFamily;\n    ctx.fillStyle = contrastColor;\n    ctx.textAlign = \"center\";\n    ctx.fillText(buttonText, centerX, centerY + 3);\n    ctx.stroke();\n\n    // Draw outer circle\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, size / 2, 0, PI2, false);\n    ctx.closePath();\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = primaryColor;\n    ctx.stroke();\n  };\n  const drawNeedle = () => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = contrastColor;\n    ctx.fillStyle = contrastColor;\n    ctx.beginPath();\n    ctx.moveTo(centerX + 20, centerY - 50);\n    ctx.lineTo(centerX - 20, centerY - 50);\n    ctx.lineTo(centerX, centerY - 70);\n    ctx.closePath();\n    ctx.fill();\n    const change = angleCurrent + Math.PI / 2;\n    let i = segments.length - Math.floor(change / (Math.PI * 2) * segments.length) - 1;\n    if (i < 0) i = i + segments.length;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillStyle = primaryColor;\n    ctx.font = \"bold 1.5em \" + fontFamily;\n    currentSegment = segments[i];\n  };\n  const clear = () => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    ctx.clearRect(0, 0, dimension, dimension);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    id: wheelId.current,\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      id: canvasId.current,\n      width: dimension,\n      height: dimension,\n      style: {\n        pointerEvents: isFinished && isOnlyOnce ? \"none\" : \"auto\"\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 233,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 232,\n    columnNumber: 5\n  }, this);\n};\n_s(WheelComponent, \"R43FBdw/DOTsz5Oe2umAcDTPoI0=\");\n_c = WheelComponent;\nexport default WheelComponent;\nvar _c;\n$RefreshReg$(_c, \"WheelComponent\");","map":{"version":3,"names":["useEffect","useState","useRef","jsxDEV","_jsxDEV","WheelComponent","segments","segColors","winningSegment","onFinished","primaryColor","contrastColor","buttonText","isOnlyOnce","size","upDuration","downDuration","fontFamily","_s","randomString","chars","split","length","str","i","Math","floor","random","canvasId","wheelId","dimension","currentSegment","isStarted","isFinished","setFinished","timerHandle","timerDelay","angleCurrent","angleDelta","canvasContext","maxSpeed","PI","upTime","downTime","spinStart","frames","centerX","centerY","wheelInit","setTimeout","window","scrollTo","initCanvas","wheelDraw","_canvas","canvas","document","getElementById","current","navigator","userAgent","indexOf","_document$getElementB","createElement","setAttribute","appendChild","addEventListener","spin","getContext","Date","getTime","setInterval","onTimerTick","draw","duration","progress","finished","sin","clearInterval","clear","drawWheel","drawNeedle","drawSegment","key","lastAngle","angle","ctx","value","save","beginPath","moveTo","arc","lineTo","closePath","fillStyle","fill","stroke","translate","rotate","font","fillText","substr","restore","len","PI2","lineWidth","strokeStyle","textBaseline","textAlign","change","clearRect","id","children","width","height","style","pointerEvents","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/gaspa/OneDrive/Documents/MMI 2/S4/React/SpinningWheel/spin-wheel/src/components/WheelConstructor.jsx"],"sourcesContent":["import { useEffect, useState, useRef } from \"react\";\n\nconst WheelComponent = ({\n  segments,\n  segColors,\n  winningSegment,\n  onFinished,\n  primaryColor = \"black\",\n  contrastColor = \"white\",\n  buttonText = \"Spin\",\n  isOnlyOnce = true,\n  size = 300, // Utilisation d'une taille fixe\n  upDuration = 100,\n  downDuration = 1000,\n  fontFamily = \"Arial, sans-serif\", // Utilisation d'une police web standard\n}) => {\n  const randomString = () => {\n    const chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\".split(\n      \"\"\n    );\n    const length = 8;\n    let str = \"\";\n    for (let i = 0; i < length; i++) {\n      str += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return str;\n  };\n  const canvasId = useRef(`canvas-${randomString()}`);\n  const wheelId = useRef(`wheel-${randomString()}`);\n  const dimension = size; // Utilisation de la taille fixe pour le canvas\n  let currentSegment = \"\";\n  let isStarted = false;\n  const [isFinished, setFinished] = useState(false);\n  let timerHandle = 0;\n  const timerDelay = segments.length;\n  let angleCurrent = 0;\n  let angleDelta = 0;\n  let canvasContext = null;\n  let maxSpeed = Math.PI / segments.length;\n  const upTime = segments.length * upDuration;\n  const downTime = segments.length * downDuration;\n  let spinStart = 0;\n  let frames = 0;\n  const centerX = size / 2;\n  const centerY = size / 2;\n  useEffect(() => {\n    wheelInit();\n    setTimeout(() => {\n      window.scrollTo(0, 1);\n    }, 0);\n  }, []);\n  const wheelInit = () => {\n    initCanvas();\n    wheelDraw();\n  };\n\n  const initCanvas = () => {\n    let canvas = document.getElementById(canvasId.current);\n    if (navigator.userAgent.indexOf(\"MSIE\") !== -1) {\n      canvas = document.createElement(\"canvas\");\n      canvas.setAttribute(\"width\", `${dimension}`);\n      canvas.setAttribute(\"height\", `${dimension}`);\n      canvas.setAttribute(\"id\", canvasId.current);\n      document.getElementById(wheelId.current)?.appendChild(canvas);\n    }\n    canvas?.addEventListener(\"click\", spin, false);\n    canvasContext = canvas.getContext(\"2d\");\n  };\n  const spin = () => {\n    isStarted = true;\n    if (timerHandle === 0) {\n      spinStart = new Date().getTime();\n      maxSpeed = Math.PI / segments.length;\n      frames = 0;\n      timerHandle = setInterval(onTimerTick, timerDelay);\n    }\n  };\n  const onTimerTick = () => {\n    frames++;\n    draw();\n    const duration = new Date().getTime() - spinStart;\n    let progress = 0;\n    let finished = false;\n    if (duration < upTime) {\n      progress = duration / upTime;\n      angleDelta = maxSpeed * Math.sin((progress * Math.PI) / 2);\n    } else {\n      if (winningSegment) {\n        if (currentSegment === winningSegment && frames > segments.length) {\n          progress = duration / upTime;\n          angleDelta =\n            maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2);\n          progress = 1;\n        } else {\n          progress = duration / downTime;\n          angleDelta =\n            maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2);\n        }\n      } else {\n        progress = duration / downTime;\n        angleDelta =\n          maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2);\n      }\n      if (progress >= 1) finished = true;\n    }\n\n    angleCurrent += angleDelta;\n    while (angleCurrent >= Math.PI * 2) angleCurrent -= Math.PI * 2;\n    if (finished) {\n      setFinished(true);\n      onFinished(currentSegment);\n      clearInterval(timerHandle);\n      timerHandle = 0;\n      angleDelta = 0;\n    }\n  };\n\n  const wheelDraw = () => {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n\n  const draw = () => {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n\n  const drawSegment = (key, lastAngle, angle) => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    const value = segments[key];\n    ctx.save();\n    ctx.beginPath();\n    ctx.moveTo(centerX, centerY);\n    ctx.arc(centerX, centerY, size / 2, lastAngle, angle, false);\n    ctx.lineTo(centerX, centerY);\n    ctx.closePath();\n    ctx.fillStyle = segColors[key];\n    ctx.fill();\n    ctx.stroke();\n    ctx.save();\n    ctx.translate(centerX, centerY);\n    ctx.rotate((lastAngle + angle) / 2);\n    ctx.fillStyle = contrastColor;\n    ctx.font = \"bold 1em \" + fontFamily;\n    ctx.fillText(value.substr(0, 21), size / 2 + 20, 0);\n    ctx.restore();\n  };\n\n  const drawWheel = () => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    let lastAngle = angleCurrent;\n    const len = segments.length;\n    const PI2 = Math.PI * 2;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = primaryColor;\n    ctx.textBaseline = \"middle\";\n    ctx.textAlign = \"center\";\n    ctx.font = \"1em \" + fontFamily;\n    for (let i = 1; i <= len; i++) {\n      const angle = PI2 * (i / len) + angleCurrent;\n      drawSegment(i - 1, lastAngle, angle);\n      lastAngle = angle;\n    }\n\n    // Draw a center circle\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, 50, 0, PI2, false);\n    ctx.closePath();\n    ctx.fillStyle = primaryColor;\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = contrastColor;\n    ctx.fill();\n    ctx.font = \"bold 2em \" + fontFamily;\n    ctx.fillStyle = contrastColor;\n    ctx.textAlign = \"center\";\n    ctx.fillText(buttonText, centerX, centerY + 3);\n    ctx.stroke();\n\n    // Draw outer circle\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, size / 2, 0, PI2, false);\n    ctx.closePath();\n\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = primaryColor;\n    ctx.stroke();\n  };\n\n  const drawNeedle = () => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = contrastColor;\n    ctx.fillStyle = contrastColor;\n    ctx.beginPath();\n    ctx.moveTo(centerX + 20, centerY - 50);\n    ctx.lineTo(centerX - 20, centerY - 50);\n    ctx.lineTo(centerX, centerY - 70);\n    ctx.closePath();\n    ctx.fill();\n    const change = angleCurrent + Math.PI / 2;\n    let i =\n      segments.length -\n      Math.floor((change / (Math.PI * 2)) * segments.length) -\n      1;\n    if (i < 0) i = i + segments.length;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillStyle = primaryColor;\n    ctx.font = \"bold 1.5em \" + fontFamily;\n    currentSegment = segments[i];\n    \n  };\n  const clear = () => {\n    if (!canvasContext) {\n      return false;\n    }\n    const ctx = canvasContext;\n    ctx.clearRect(0, 0, dimension, dimension);\n  };\n  return (\n    <div id={wheelId.current}>\n      <canvas\n        id={canvasId.current}\n        width={dimension}\n        height={dimension}\n        style={{\n          pointerEvents: isFinished && isOnlyOnce ? \"none\" : \"auto\",\n        }}\n      />\n    </div>\n  );\n};\nexport default WheelComponent;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}