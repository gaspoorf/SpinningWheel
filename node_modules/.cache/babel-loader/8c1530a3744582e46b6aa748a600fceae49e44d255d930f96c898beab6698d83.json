{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\gaspa\\\\OneDrive\\\\Documents\\\\MMI 2\\\\S4\\\\React\\\\SpinningWheel\\\\spin-wheel\\\\src\\\\components\\\\WheelConstructor.jsx\",\n  _s = $RefreshSig$();\nimport { useEffect, useState, useRef } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WheelComponent = ({\n  segments,\n  segColors,\n  winningSegment,\n  onFinished,\n  primaryColor = \"black\",\n  contrastColor = \"white\",\n  buttonText = \"Spin\",\n  isOnlyOnce = true,\n  size = window.innerWidth,\n  upDuration = 100,\n  downDuration = 1000,\n  fontFamily = \"proxima-nova\"\n}) => {\n  _s();\n  const randomString = () => {\n    const chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\".split(\"\");\n    const length = 8;\n    let str = \"\";\n    for (let i = 0; i < length; i++) {\n      str += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return str;\n  };\n  const canvasId = useRef(`canvas-${randomString()}`);\n  const wheelId = useRef(`wheel-${randomString()}`);\n  const dimension = size + 20; // La taille du canvas correspond à celle du composant\n  let currentSegment = \"\";\n  let isStarted = false;\n  const [isFinished, setFinished] = useState(false);\n  let timerHandle = 0;\n  const timerDelay = segments.length;\n  let angleCurrent = 0;\n  let angleDelta = 0;\n  let canvasContext = null;\n  const dpr = window.devicePixelRatio || 1; // Ratio de densité de pixels\n  useEffect(() => {\n    wheelInit();\n    setTimeout(() => {\n      window.scrollTo(0, 1);\n    }, 0);\n  }, []);\n  const wheelInit = () => {\n    initCanvas();\n    wheelDraw();\n  };\n  const initCanvas = () => {\n    var _canvas;\n    let canvas = document.getElementById(canvasId.current);\n    if (navigator.userAgent.indexOf(\"MSIE\") !== -1) {\n      var _document$getElementB;\n      canvas = document.createElement(\"canvas\");\n      canvas.setAttribute(\"width\", `${dimension * dpr}`);\n      canvas.setAttribute(\"height\", `${dimension * dpr}`);\n      canvas.setAttribute(\"id\", canvasId.current);\n      (_document$getElementB = document.getElementById(wheelId.current)) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.appendChild(canvas);\n    }\n    (_canvas = canvas) === null || _canvas === void 0 ? void 0 : _canvas.addEventListener(\"click\", spin, false);\n    canvasContext = canvas.getContext(\"2d\");\n    canvasContext.scale(dpr, dpr); // Mise à l'échelle selon le ratio de densité de pixels\n    canvas.style.width = dimension + \"px\";\n    canvas.style.height = dimension + \"px\";\n  };\n  const spin = () => {\n    isStarted = true;\n    if (timerHandle === 0) {\n      const spinStart = new Date().getTime();\n      const maxSpeed = Math.PI / segments.length;\n      let frames = 0;\n      timerHandle = setInterval(() => onTimerTick(spinStart, maxSpeed, ++frames), timerDelay);\n    }\n  };\n  const onTimerTick = (spinStart, maxSpeed, frames) => {\n    draw();\n    const duration = new Date().getTime() - spinStart;\n    let progress = 0;\n    let finished = false;\n    if (duration < upDuration * segments.length) {\n      progress = duration / (upDuration * segments.length);\n      angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2);\n    } else {\n      if (winningSegment) {\n        if (currentSegment === winningSegment && frames > segments.length) {\n          progress = duration / (upDuration * segments.length);\n          angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n          progress = 1;\n        } else {\n          progress = duration / (downDuration * segments.length);\n          angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n        }\n      } else {\n        progress = duration / (downDuration * segments.length);\n        angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n      }\n      if (progress >= 1) finished = true;\n    }\n    angleCurrent += angleDelta;\n    while (angleCurrent >= Math.PI * 2) angleCurrent -= Math.PI * 2;\n    if (finished) {\n      setFinished(true);\n      onFinished(currentSegment);\n      clearInterval(timerHandle);\n      timerHandle = 0;\n      angleDelta = 0;\n    }\n  };\n  const wheelDraw = () => {\n    draw();\n  };\n  const draw = () => {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n  const drawSegment = (key, lastAngle, angle) => {\n    const ctx = canvasContext;\n    const value = segments[key];\n    ctx.save();\n    ctx.beginPath();\n    ctx.moveTo(dimension / 2, dimension / 2);\n    ctx.arc(dimension / 2, dimension / 2, dimension / 2, lastAngle, angle, false);\n    ctx.lineTo(dimension / 2, dimension / 2);\n    ctx.closePath();\n    ctx.fillStyle = segColors[key];\n    ctx.fill();\n    ctx.stroke();\n    ctx.save();\n    ctx.translate(dimension / 2, dimension / 2);\n    ctx.rotate((lastAngle + angle) / 2);\n    ctx.fillStyle = contrastColor;\n    ctx.font = \"bold 1em \" + fontFamily;\n    ctx.fillText(value.substr(0, 21), dimension / 2 + 20, 0);\n    ctx.restore();\n  };\n  const drawWheel = () => {\n    const ctx = canvasContext;\n    let lastAngle = angleCurrent;\n    const len = segments.length;\n    const PI2 = Math.PI * 2;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = primaryColor;\n    ctx.textBaseline = \"middle\";\n    ctx.textAlign = \"center\";\n    ctx.font = \"1em \" + fontFamily;\n    for (let i = 1; i <= len; i++) {\n      const angle = PI2 * (i / len) + angleCurrent;\n      drawSegment(i - 1, lastAngle, angle);\n      lastAngle = angle;\n    }\n\n    // Draw a center circle\n    ctx.beginPath();\n    ctx.arc(dimension / 2, dimension / 2, 50, 0, PI2, false);\n    ctx.closePath();\n    ctx.fillStyle = primaryColor;\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = contrastColor;\n    ctx.fill();\n    ctx.font = \"bold 2em \" + fontFamily;\n    ctx.fillStyle = contrastColor;\n    ctx.textAlign = \"center\";\n    ctx.fillText(buttonText, dimension / 2, dimension / 2 + 3);\n    ctx.stroke();\n\n    // Draw outer circle\n    ctx.beginPath();\n    ctx.arc(dimension / 2, dimension / 2, dimension / 2, 0, PI2, false);\n    ctx.closePath();\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = primaryColor;\n    ctx.stroke();\n  };\n  const drawNeedle = () => {\n    const ctx = canvasContext;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = contrastColor;\n    ctx.fillStyle = contrastColor;\n    ctx.beginPath();\n    ctx.moveTo(dimension / 2 + 20, dimension / 2 - 50);\n    ctx.lineTo(dimension / 2 - 20, dimension / 2 - 50);\n    ctx.lineTo(dimension / 2, dimension / 2 - 70);\n    ctx.closePath();\n    ctx.fill();\n    const change = angleCurrent + Math.PI / 2;\n    let i = segments.length - Math.floor(change / (Math.PI * 2) * segments.length) - 1;\n    if (i < 0) i = i + segments.length;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillStyle = primaryColor;\n    ctx.font = \"bold 1.5em \" + fontFamily;\n    currentSegment = segments[i];\n  };\n  const clear = () => {\n    const ctx = canvasContext;\n    ctx.clearRect(0, 0, dimension * dpr, dimension * dpr); // Efface le canvas à la résolution native\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    id: wheelId.current,\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      id: canvasId.current,\n      width: dimension * dpr * 2,\n      height: dimension * dpr * 2,\n      style: {\n        width: dimension + \"px\",\n        // Taille affichée\n        height: dimension + \"px\",\n        pointerEvents: isFinished && isOnlyOnce ? \"none\" : \"auto\"\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 213,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 212,\n    columnNumber: 5\n  }, this);\n};\n_s(WheelComponent, \"R43FBdw/DOTsz5Oe2umAcDTPoI0=\");\n_c = WheelComponent;\nexport default WheelComponent;\nvar _c;\n$RefreshReg$(_c, \"WheelComponent\");","map":{"version":3,"names":["useEffect","useState","useRef","jsxDEV","_jsxDEV","WheelComponent","segments","segColors","winningSegment","onFinished","primaryColor","contrastColor","buttonText","isOnlyOnce","size","window","innerWidth","upDuration","downDuration","fontFamily","_s","randomString","chars","split","length","str","i","Math","floor","random","canvasId","wheelId","dimension","currentSegment","isStarted","isFinished","setFinished","timerHandle","timerDelay","angleCurrent","angleDelta","canvasContext","dpr","devicePixelRatio","wheelInit","setTimeout","scrollTo","initCanvas","wheelDraw","_canvas","canvas","document","getElementById","current","navigator","userAgent","indexOf","_document$getElementB","createElement","setAttribute","appendChild","addEventListener","spin","getContext","scale","style","width","height","spinStart","Date","getTime","maxSpeed","PI","frames","setInterval","onTimerTick","draw","duration","progress","finished","sin","clearInterval","clear","drawWheel","drawNeedle","drawSegment","key","lastAngle","angle","ctx","value","save","beginPath","moveTo","arc","lineTo","closePath","fillStyle","fill","stroke","translate","rotate","font","fillText","substr","restore","len","PI2","lineWidth","strokeStyle","textBaseline","textAlign","change","clearRect","id","children","pointerEvents","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/gaspa/OneDrive/Documents/MMI 2/S4/React/SpinningWheel/spin-wheel/src/components/WheelConstructor.jsx"],"sourcesContent":["import { useEffect, useState, useRef } from \"react\";\n\nconst WheelComponent = ({\n  segments,\n  segColors,\n  winningSegment,\n  onFinished,\n  primaryColor = \"black\",\n  contrastColor = \"white\",\n  buttonText = \"Spin\",\n  isOnlyOnce = true,\n  size = window.innerWidth,\n  upDuration = 100,\n  downDuration = 1000,\n  fontFamily = \"proxima-nova\",\n}) => {\n  const randomString = () => {\n    const chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz\".split(\"\");\n    const length = 8;\n    let str = \"\";\n    for (let i = 0; i < length; i++) {\n      str += chars[Math.floor(Math.random() * chars.length)];\n    }\n    return str;\n  };\n  const canvasId = useRef(`canvas-${randomString()}`);\n  const wheelId = useRef(`wheel-${randomString()}`);\n  const dimension = size + 20; // La taille du canvas correspond à celle du composant\n  let currentSegment = \"\";\n  let isStarted = false;\n  const [isFinished, setFinished] = useState(false);\n  let timerHandle = 0;\n  const timerDelay = segments.length;\n  let angleCurrent = 0;\n  let angleDelta = 0;\n  let canvasContext = null;\n  const dpr = window.devicePixelRatio || 1; // Ratio de densité de pixels\n  useEffect(() => {\n    wheelInit();\n    setTimeout(() => {\n      window.scrollTo(0, 1);\n    }, 0);\n  }, []);\n  const wheelInit = () => {\n    initCanvas();\n    wheelDraw();\n  };\n\n  const initCanvas = () => {\n    let canvas = document.getElementById(canvasId.current);\n    if (navigator.userAgent.indexOf(\"MSIE\") !== -1) {\n      canvas = document.createElement(\"canvas\");\n      canvas.setAttribute(\"width\", `${dimension * dpr}`);\n      canvas.setAttribute(\"height\", `${dimension * dpr}`);\n      canvas.setAttribute(\"id\", canvasId.current);\n      document.getElementById(wheelId.current)?.appendChild(canvas);\n    }\n    canvas?.addEventListener(\"click\", spin, false);\n    canvasContext = canvas.getContext(\"2d\");\n    canvasContext.scale(dpr, dpr); // Mise à l'échelle selon le ratio de densité de pixels\n    canvas.style.width = dimension + \"px\";\n    canvas.style.height = dimension + \"px\";\n  };\n\n  const spin = () => {\n    isStarted = true;\n    if (timerHandle === 0) {\n      const spinStart = new Date().getTime();\n      const maxSpeed = Math.PI / segments.length;\n      let frames = 0;\n      timerHandle = setInterval(() => onTimerTick(spinStart, maxSpeed, ++frames), timerDelay);\n    }\n  };\n\n  const onTimerTick = (spinStart, maxSpeed, frames) => {\n    draw();\n    const duration = new Date().getTime() - spinStart;\n    let progress = 0;\n    let finished = false;\n    if (duration < upDuration * segments.length) {\n      progress = duration / (upDuration * segments.length);\n      angleDelta = maxSpeed * Math.sin((progress * Math.PI) / 2);\n    } else {\n      if (winningSegment) {\n        if (currentSegment === winningSegment && frames > segments.length) {\n          progress = duration / (upDuration * segments.length);\n          angleDelta = maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2);\n          progress = 1;\n        } else {\n          progress = duration / (downDuration * segments.length);\n          angleDelta = maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2);\n        }\n      } else {\n        progress = duration / (downDuration * segments.length);\n        angleDelta = maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2);\n      }\n      if (progress >= 1) finished = true;\n    }\n\n    angleCurrent += angleDelta;\n    while (angleCurrent >= Math.PI * 2) angleCurrent -= Math.PI * 2;\n    if (finished) {\n      setFinished(true);\n      onFinished(currentSegment);\n      clearInterval(timerHandle);\n      timerHandle = 0;\n      angleDelta = 0;\n    }\n  };\n\n  const wheelDraw = () => {\n    draw();\n  };\n\n  const draw = () => {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n\n  const drawSegment = (key, lastAngle, angle) => {\n    const ctx = canvasContext;\n    const value = segments[key];\n    ctx.save();\n    ctx.beginPath();\n    ctx.moveTo(dimension / 2, dimension / 2);\n    ctx.arc(dimension / 2, dimension / 2, dimension / 2, lastAngle, angle, false);\n    ctx.lineTo(dimension / 2, dimension / 2);\n    ctx.closePath();\n    ctx.fillStyle = segColors[key];\n    ctx.fill();\n    ctx.stroke();\n    ctx.save();\n    ctx.translate(dimension / 2, dimension / 2);\n    ctx.rotate((lastAngle + angle) / 2);\n    ctx.fillStyle = contrastColor;\n    ctx.font = \"bold 1em \" + fontFamily;\n    ctx.fillText(value.substr(0, 21), dimension / 2 + 20, 0);\n    ctx.restore();\n  };\n\n  const drawWheel = () => {\n    const ctx = canvasContext;\n    let lastAngle = angleCurrent;\n    const len = segments.length;\n    const PI2 = Math.PI * 2;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = primaryColor;\n    ctx.textBaseline = \"middle\";\n    ctx.textAlign = \"center\";\n    ctx.font = \"1em \" + fontFamily;\n    for (let i = 1; i <= len; i++) {\n      const angle = PI2 * (i / len) + angleCurrent;\n      drawSegment(i - 1, lastAngle, angle);\n      lastAngle = angle;\n    }\n\n    // Draw a center circle\n    ctx.beginPath();\n    ctx.arc(dimension / 2, dimension / 2, 50, 0, PI2, false);\n    ctx.closePath();\n    ctx.fillStyle = primaryColor;\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = contrastColor;\n    ctx.fill();\n    ctx.font = \"bold 2em \" + fontFamily;\n    ctx.fillStyle = contrastColor;\n    ctx.textAlign = \"center\";\n    ctx.fillText(buttonText, dimension / 2, dimension / 2 + 3);\n    ctx.stroke();\n\n    // Draw outer circle\n    ctx.beginPath();\n    ctx.arc(dimension / 2, dimension / 2, dimension / 2, 0, PI2, false);\n    ctx.closePath();\n\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = primaryColor;\n    ctx.stroke();\n  };\n\n  const drawNeedle = () => {\n    const ctx = canvasContext;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = contrastColor;\n    ctx.fillStyle = contrastColor;\n    ctx.beginPath();\n    ctx.moveTo(dimension / 2 + 20, dimension / 2 - 50);\n    ctx.lineTo(dimension / 2 - 20, dimension / 2 - 50);\n    ctx.lineTo(dimension / 2, dimension / 2 - 70);\n    ctx.closePath();\n    ctx.fill();\n    const change = angleCurrent + Math.PI / 2;\n    let i =\n      segments.length -\n      Math.floor((change / (Math.PI * 2)) * segments.length) -\n      1;\n    if (i < 0) i = i + segments.length;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillStyle = primaryColor;\n    ctx.font = \"bold 1.5em \" + fontFamily;\n    currentSegment = segments[i];\n  };\n\n  const clear = () => {\n    const ctx = canvasContext;\n    ctx.clearRect(0, 0, dimension * dpr, dimension * dpr); // Efface le canvas à la résolution native\n  };\n\n  return (\n    <div id={wheelId.current}>\n      <canvas\n        id={canvasId.current}\n        width={(dimension * dpr) * 2 }\n        height={(dimension * dpr) * 2}\n        style={{\n          width: dimension + \"px\", // Taille affichée\n          height: dimension + \"px\",\n          pointerEvents: isFinished && isOnlyOnce ? \"none\" : \"auto\",\n        }}\n      />\n    </div>\n  );\n};\nexport default WheelComponent;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}