{"ast":null,"code":"module.exports = {\n  decomp: polygonDecomp,\n  quickDecomp: polygonQuickDecomp,\n  isSimple: polygonIsSimple,\n  removeCollinearPoints: polygonRemoveCollinearPoints,\n  removeDuplicatePoints: polygonRemoveDuplicatePoints,\n  makeCCW: polygonMakeCCW\n};\n\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */\nfunction lineInt(l1, l2, precision) {\n  precision = precision || 0;\n  var i = [0, 0]; // point\n  var a1, b1, c1, a2, b2, c2, det; // scalars\n  a1 = l1[1][1] - l1[0][1];\n  b1 = l1[0][0] - l1[1][0];\n  c1 = a1 * l1[0][0] + b1 * l1[0][1];\n  a2 = l2[1][1] - l2[0][1];\n  b2 = l2[0][0] - l2[1][0];\n  c2 = a2 * l2[0][0] + b2 * l2[0][1];\n  det = a1 * b2 - a2 * b1;\n  if (!scalar_eq(det, 0, precision)) {\n    // lines are not parallel\n    i[0] = (b2 * c1 - b1 * c2) / det;\n    i[1] = (a1 * c2 - a2 * c1) / det;\n  }\n  return i;\n}\n\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */\nfunction lineSegmentsIntersect(p1, p2, q1, q2) {\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var da = q2[0] - q1[0];\n  var db = q2[1] - q1[1];\n\n  // segments are parallel\n  if (da * dy - db * dx === 0) {\n    return false;\n  }\n  var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n  var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n  return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n}\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */\nfunction triangleArea(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);\n}\nfunction isLeft(a, b, c) {\n  return triangleArea(a, b, c) > 0;\n}\nfunction isLeftOn(a, b, c) {\n  return triangleArea(a, b, c) >= 0;\n}\nfunction isRight(a, b, c) {\n  return triangleArea(a, b, c) < 0;\n}\nfunction isRightOn(a, b, c) {\n  return triangleArea(a, b, c) <= 0;\n}\nvar tmpPoint1 = [],\n  tmpPoint2 = [];\n\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */\nfunction collinear(a, b, c, thresholdAngle) {\n  if (!thresholdAngle) {\n    return triangleArea(a, b, c) === 0;\n  } else {\n    var ab = tmpPoint1,\n      bc = tmpPoint2;\n    ab[0] = b[0] - a[0];\n    ab[1] = b[1] - a[1];\n    bc[0] = c[0] - b[0];\n    bc[1] = c[1] - b[1];\n    var dot = ab[0] * bc[0] + ab[1] * bc[1],\n      magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]),\n      magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]),\n      angle = Math.acos(dot / (magA * magB));\n    return angle < thresholdAngle;\n  }\n}\nfunction sqdist(a, b) {\n  var dx = b[0] - a[0];\n  var dy = b[1] - a[1];\n  return dx * dx + dy * dy;\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */\nfunction polygonAt(polygon, i) {\n  var s = polygon.length;\n  return polygon[i < 0 ? i % s + s : i % s];\n}\n\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */\nfunction polygonClear(polygon) {\n  polygon.length = 0;\n}\n\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */\nfunction polygonAppend(polygon, poly, from, to) {\n  for (var i = from; i < to; i++) {\n    polygon.push(poly[i]);\n  }\n}\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */\nfunction polygonMakeCCW(polygon) {\n  var br = 0,\n    v = polygon;\n\n  // find bottom right point\n  for (var i = 1; i < polygon.length; ++i) {\n    if (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0]) {\n      br = i;\n    }\n  }\n\n  // reverse poly if clockwise\n  if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n    polygonReverse(polygon);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */\nfunction polygonReverse(polygon) {\n  var tmp = [];\n  var N = polygon.length;\n  for (var i = 0; i !== N; i++) {\n    tmp.push(polygon.pop());\n  }\n  for (var i = 0; i !== N; i++) {\n    polygon[i] = tmp[i];\n  }\n}\n\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */\nfunction polygonIsReflex(polygon, i) {\n  return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\nvar tmpLine1 = [],\n  tmpLine2 = [];\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee(polygon, a, b) {\n  var p,\n    dist,\n    l1 = tmpLine1,\n    l2 = tmpLine2;\n  if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n    return false;\n  }\n  dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n  for (var i = 0; i !== polygon.length; ++i) {\n    // for each edge\n    if ((i + 1) % polygon.length === a || i === a) {\n      // ignore incident edges\n      continue;\n    }\n    if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) {\n      // if diag intersects an edge\n      l1[0] = polygonAt(polygon, a);\n      l1[1] = polygonAt(polygon, b);\n      l2[0] = polygonAt(polygon, i);\n      l2[1] = polygonAt(polygon, i + 1);\n      p = lineInt(l1, l2);\n      if (sqdist(polygonAt(polygon, a), p) < dist) {\n        // if edge is blocking visibility to b\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee2\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee2(polygon, a, b) {\n  // for each edge\n  for (var i = 0; i !== polygon.length; ++i) {\n    // ignore incident edges\n    if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {\n      continue;\n    }\n    if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */\nfunction polygonCopy(polygon, i, j, targetPoly) {\n  var p = targetPoly || [];\n  polygonClear(p);\n  if (i < j) {\n    // Insert all vertices from i to j\n    for (var k = i; k <= j; k++) {\n      p.push(polygon[k]);\n    }\n  } else {\n    // Insert vertices 0 to j\n    for (var k = 0; k <= j; k++) {\n      p.push(polygon[k]);\n    }\n\n    // Insert vertices i to end\n    for (var k = i; k < polygon.length; k++) {\n      p.push(polygon[k]);\n    }\n  }\n  return p;\n}\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */\nfunction polygonGetCutEdges(polygon) {\n  var min = [],\n    tmp1 = [],\n    tmp2 = [],\n    tmpPoly = [];\n  var nDiags = Number.MAX_VALUE;\n  for (var i = 0; i < polygon.length; ++i) {\n    if (polygonIsReflex(polygon, i)) {\n      for (var j = 0; j < polygon.length; ++j) {\n        if (polygonCanSee(polygon, i, j)) {\n          tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n          tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n          for (var k = 0; k < tmp2.length; k++) {\n            tmp1.push(tmp2[k]);\n          }\n          if (tmp1.length < nDiags) {\n            min = tmp1;\n            nDiags = tmp1.length;\n            min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n          }\n        }\n      }\n    }\n  }\n  return min;\n}\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */\nfunction polygonDecomp(polygon) {\n  var edges = polygonGetCutEdges(polygon);\n  if (edges.length > 0) {\n    return polygonSlice(polygon, edges);\n  } else {\n    return [polygon];\n  }\n}\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */\nfunction polygonSlice(polygon, cutEdges) {\n  if (cutEdges.length === 0) {\n    return [polygon];\n  }\n  if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {\n    var polys = [polygon];\n    for (var i = 0; i < cutEdges.length; i++) {\n      var cutEdge = cutEdges[i];\n      // Cut all polys\n      for (var j = 0; j < polys.length; j++) {\n        var poly = polys[j];\n        var result = polygonSlice(poly, cutEdge);\n        if (result) {\n          // Found poly! Cut and quit\n          polys.splice(j, 1);\n          polys.push(result[0], result[1]);\n          break;\n        }\n      }\n    }\n    return polys;\n  } else {\n    // Was given one edge\n    var cutEdge = cutEdges;\n    var i = polygon.indexOf(cutEdge[0]);\n    var j = polygon.indexOf(cutEdge[1]);\n    if (i !== -1 && j !== -1) {\n      return [polygonCopy(polygon, i, j), polygonCopy(polygon, j, i)];\n    } else {\n      return false;\n    }\n  }\n}\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */\nfunction polygonIsSimple(polygon) {\n  var path = polygon,\n    i;\n  // Check\n  for (i = 0; i < path.length - 1; i++) {\n    for (var j = 0; j < i - 1; j++) {\n      if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {\n        return false;\n      }\n    }\n  }\n\n  // Check the segment between the last and the first point to all others\n  for (i = 1; i < path.length - 2; i++) {\n    if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getIntersectionPoint(p1, p2, q1, q2, delta) {\n  delta = delta || 0;\n  var a1 = p2[1] - p1[1];\n  var b1 = p1[0] - p2[0];\n  var c1 = a1 * p1[0] + b1 * p1[1];\n  var a2 = q2[1] - q1[1];\n  var b2 = q1[0] - q2[0];\n  var c2 = a2 * q1[0] + b2 * q1[1];\n  var det = a1 * b2 - a2 * b1;\n  if (!scalar_eq(det, 0, delta)) {\n    return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];\n  } else {\n    return [0, 0];\n  }\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */\nfunction polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {\n  maxlevel = maxlevel || 100;\n  level = level || 0;\n  delta = delta || 25;\n  result = typeof result !== \"undefined\" ? result : [];\n  reflexVertices = reflexVertices || [];\n  steinerPoints = steinerPoints || [];\n  var upperInt = [0, 0],\n    lowerInt = [0, 0],\n    p = [0, 0]; // Points\n  var upperDist = 0,\n    lowerDist = 0,\n    d = 0,\n    closestDist = 0; // scalars\n  var upperIndex = 0,\n    lowerIndex = 0,\n    closestIndex = 0; // Integers\n  var lowerPoly = [],\n    upperPoly = []; // polygons\n  var poly = polygon,\n    v = polygon;\n  if (v.length < 3) {\n    return result;\n  }\n  level++;\n  if (level > maxlevel) {\n    console.warn(\"quickDecomp: max level (\" + maxlevel + \") reached.\");\n    return result;\n  }\n  for (var i = 0; i < polygon.length; ++i) {\n    if (polygonIsReflex(poly, i)) {\n      reflexVertices.push(poly[i]);\n      upperDist = lowerDist = Number.MAX_VALUE;\n      for (var j = 0; j < polygon.length; ++j) {\n        if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {\n          // if line intersects with an edge\n          p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n          if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) {\n            // make sure it's inside the poly\n            d = sqdist(poly[i], p);\n            if (d < lowerDist) {\n              // keep only the closest intersection\n              lowerDist = d;\n              lowerInt = p;\n              lowerIndex = j;\n            }\n          }\n        }\n        if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n          p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n          if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n            d = sqdist(poly[i], p);\n            if (d < upperDist) {\n              upperDist = d;\n              upperInt = p;\n              upperIndex = j;\n            }\n          }\n        }\n      }\n\n      // if there are no vertices to connect to, choose a point in the middle\n      if (lowerIndex === (upperIndex + 1) % polygon.length) {\n        //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n        p[0] = (lowerInt[0] + upperInt[0]) / 2;\n        p[1] = (lowerInt[1] + upperInt[1]) / 2;\n        steinerPoints.push(p);\n        if (i < upperIndex) {\n          //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n          polygonAppend(lowerPoly, poly, i, upperIndex + 1);\n          lowerPoly.push(p);\n          upperPoly.push(p);\n          if (lowerIndex !== 0) {\n            //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n            polygonAppend(upperPoly, poly, lowerIndex, poly.length);\n          }\n          //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n          polygonAppend(upperPoly, poly, 0, i + 1);\n        } else {\n          if (i !== 0) {\n            //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n            polygonAppend(lowerPoly, poly, i, poly.length);\n          }\n          //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n          polygonAppend(lowerPoly, poly, 0, upperIndex + 1);\n          lowerPoly.push(p);\n          upperPoly.push(p);\n          //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n          polygonAppend(upperPoly, poly, lowerIndex, i + 1);\n        }\n      } else {\n        // connect to the closest point within the triangle\n        //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n\n        if (lowerIndex > upperIndex) {\n          upperIndex += polygon.length;\n        }\n        closestDist = Number.MAX_VALUE;\n        if (upperIndex < lowerIndex) {\n          return result;\n        }\n        for (var j = lowerIndex; j <= upperIndex; ++j) {\n          if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n            d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n            if (d < closestDist && polygonCanSee2(poly, i, j)) {\n              closestDist = d;\n              closestIndex = j % polygon.length;\n            }\n          }\n        }\n        if (i < closestIndex) {\n          polygonAppend(lowerPoly, poly, i, closestIndex + 1);\n          if (closestIndex !== 0) {\n            polygonAppend(upperPoly, poly, closestIndex, v.length);\n          }\n          polygonAppend(upperPoly, poly, 0, i + 1);\n        } else {\n          if (i !== 0) {\n            polygonAppend(lowerPoly, poly, i, v.length);\n          }\n          polygonAppend(lowerPoly, poly, 0, closestIndex + 1);\n          polygonAppend(upperPoly, poly, closestIndex, i + 1);\n        }\n      }\n\n      // solve smallest poly first\n      if (lowerPoly.length < upperPoly.length) {\n        polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n        polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n      } else {\n        polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n        polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n      }\n      return result;\n    }\n  }\n  result.push(polygon);\n  return result;\n}\n\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */\nfunction polygonRemoveCollinearPoints(polygon, precision) {\n  var num = 0;\n  for (var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {\n    if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {\n      // Remove the middle point\n      polygon.splice(i % polygon.length, 1);\n      num++;\n    }\n  }\n  return num;\n}\n\n/**\n * Remove duplicate points in the polygon.\n * @method removeDuplicatePoints\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\n */\nfunction polygonRemoveDuplicatePoints(polygon, precision) {\n  for (var i = polygon.length - 1; i >= 1; --i) {\n    var pi = polygon[i];\n    for (var j = i - 1; j >= 0; --j) {\n      if (points_eq(pi, polygon[j], precision)) {\n        polygon.splice(i, 1);\n        continue;\n      }\n    }\n  }\n}\n\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction scalar_eq(a, b, precision) {\n  precision = precision || 0;\n  return Math.abs(a - b) <= precision;\n}\n\n/**\n * Check if two points are equal\n * @static\n * @method points_eq\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction points_eq(a, b, precision) {\n  return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);\n}","map":{"version":3,"names":["module","exports","decomp","polygonDecomp","quickDecomp","polygonQuickDecomp","isSimple","polygonIsSimple","removeCollinearPoints","polygonRemoveCollinearPoints","removeDuplicatePoints","polygonRemoveDuplicatePoints","makeCCW","polygonMakeCCW","lineInt","l1","l2","precision","i","a1","b1","c1","a2","b2","c2","det","scalar_eq","lineSegmentsIntersect","p1","p2","q1","q2","dx","dy","da","db","s","t","triangleArea","a","b","c","isLeft","isLeftOn","isRight","isRightOn","tmpPoint1","tmpPoint2","collinear","thresholdAngle","ab","bc","dot","magA","Math","sqrt","magB","angle","acos","sqdist","polygonAt","polygon","length","polygonClear","polygonAppend","poly","from","to","push","br","v","polygonReverse","tmp","N","pop","polygonIsReflex","tmpLine1","tmpLine2","polygonCanSee","p","dist","polygonCanSee2","polygonCopy","j","targetPoly","k","polygonGetCutEdges","min","tmp1","tmp2","tmpPoly","nDiags","Number","MAX_VALUE","edges","polygonSlice","cutEdges","Array","polys","cutEdge","result","splice","indexOf","path","getIntersectionPoint","delta","reflexVertices","steinerPoints","maxlevel","level","upperInt","lowerInt","upperDist","lowerDist","d","closestDist","upperIndex","lowerIndex","closestIndex","lowerPoly","upperPoly","console","warn","num","pi","points_eq","abs"],"sources":["C:/Users/gaspa/OneDrive/Documents/MMI 2/S4/React/SpinningWheel/spin-wheel/node_modules/poly-decomp/src/index.js"],"sourcesContent":["module.exports = {\n    decomp: polygonDecomp,\n    quickDecomp: polygonQuickDecomp,\n    isSimple: polygonIsSimple,\n    removeCollinearPoints: polygonRemoveCollinearPoints,\n    removeDuplicatePoints: polygonRemoveDuplicatePoints,\n    makeCCW: polygonMakeCCW\n};\n\n/**\n * Compute the intersection between two lines.\n * @static\n * @method lineInt\n * @param  {Array}  l1          Line vector 1\n * @param  {Array}  l2          Line vector 2\n * @param  {Number} precision   Precision to use when checking if the lines are parallel\n * @return {Array}              The intersection point.\n */\nfunction lineInt(l1,l2,precision){\n    precision = precision || 0;\n    var i = [0,0]; // point\n    var a1, b1, c1, a2, b2, c2, det; // scalars\n    a1 = l1[1][1] - l1[0][1];\n    b1 = l1[0][0] - l1[1][0];\n    c1 = a1 * l1[0][0] + b1 * l1[0][1];\n    a2 = l2[1][1] - l2[0][1];\n    b2 = l2[0][0] - l2[1][0];\n    c2 = a2 * l2[0][0] + b2 * l2[0][1];\n    det = a1 * b2 - a2*b1;\n    if (!scalar_eq(det, 0, precision)) { // lines are not parallel\n        i[0] = (b2 * c1 - b1 * c2) / det;\n        i[1] = (a1 * c2 - a2 * c1) / det;\n    }\n    return i;\n}\n\n/**\n * Checks if two line segments intersects.\n * @method segmentsIntersect\n * @param {Array} p1 The start vertex of the first line segment.\n * @param {Array} p2 The end vertex of the first line segment.\n * @param {Array} q1 The start vertex of the second line segment.\n * @param {Array} q2 The end vertex of the second line segment.\n * @return {Boolean} True if the two line segments intersect\n */\nfunction lineSegmentsIntersect(p1, p2, q1, q2){\n\tvar dx = p2[0] - p1[0];\n\tvar dy = p2[1] - p1[1];\n\tvar da = q2[0] - q1[0];\n\tvar db = q2[1] - q1[1];\n\n\t// segments are parallel\n\tif((da*dy - db*dx) === 0){\n\t\treturn false;\n\t}\n\n\tvar s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n\tvar t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n\n\treturn (s>=0 && s<=1 && t>=0 && t<=1);\n}\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @static\n * @method area\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @return {Number}\n */\nfunction triangleArea(a,b,c){\n    return (((b[0] - a[0])*(c[1] - a[1]))-((c[0] - a[0])*(b[1] - a[1])));\n}\n\nfunction isLeft(a,b,c){\n    return triangleArea(a,b,c) > 0;\n}\n\nfunction isLeftOn(a,b,c) {\n    return triangleArea(a, b, c) >= 0;\n}\n\nfunction isRight(a,b,c) {\n    return triangleArea(a, b, c) < 0;\n}\n\nfunction isRightOn(a,b,c) {\n    return triangleArea(a, b, c) <= 0;\n}\n\nvar tmpPoint1 = [],\n    tmpPoint2 = [];\n\n/**\n * Check if three points are collinear\n * @method collinear\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Array} c\n * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return {Boolean}\n */\nfunction collinear(a,b,c,thresholdAngle) {\n    if(!thresholdAngle){\n        return triangleArea(a, b, c) === 0;\n    } else {\n        var ab = tmpPoint1,\n            bc = tmpPoint2;\n\n        ab[0] = b[0]-a[0];\n        ab[1] = b[1]-a[1];\n        bc[0] = c[0]-b[0];\n        bc[1] = c[1]-b[1];\n\n        var dot = ab[0]*bc[0] + ab[1]*bc[1],\n            magA = Math.sqrt(ab[0]*ab[0] + ab[1]*ab[1]),\n            magB = Math.sqrt(bc[0]*bc[0] + bc[1]*bc[1]),\n            angle = Math.acos(dot/(magA*magB));\n        return angle < thresholdAngle;\n    }\n}\n\nfunction sqdist(a,b){\n    var dx = b[0] - a[0];\n    var dy = b[1] - a[1];\n    return dx * dx + dy * dy;\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @method at\n * @param  {Number} i\n * @return {Array}\n */\nfunction polygonAt(polygon, i){\n    var s = polygon.length;\n    return polygon[i < 0 ? i % s + s : i % s];\n}\n\n/**\n * Clear the polygon data\n * @method clear\n * @return {Array}\n */\nfunction polygonClear(polygon){\n    polygon.length = 0;\n}\n\n/**\n * Append points \"from\" to \"to\"-1 from an other polygon \"poly\" onto this one.\n * @method append\n * @param {Polygon} poly The polygon to get points from.\n * @param {Number}  from The vertex index in \"poly\".\n * @param {Number}  to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n * @return {Array}\n */\nfunction polygonAppend(polygon, poly, from, to){\n    for(var i=from; i<to; i++){\n        polygon.push(poly[i]);\n    }\n}\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n * @method makeCCW\n */\nfunction polygonMakeCCW(polygon){\n    var br = 0,\n        v = polygon;\n\n    // find bottom right point\n    for (var i = 1; i < polygon.length; ++i) {\n        if (v[i][1] < v[br][1] || (v[i][1] === v[br][1] && v[i][0] > v[br][0])) {\n            br = i;\n        }\n    }\n\n    // reverse poly if clockwise\n    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n        polygonReverse(polygon);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n/**\n * Reverse the vertices in the polygon\n * @method reverse\n */\nfunction polygonReverse(polygon){\n    var tmp = [];\n    var N = polygon.length;\n    for(var i=0; i!==N; i++){\n        tmp.push(polygon.pop());\n    }\n    for(var i=0; i!==N; i++){\n\t\tpolygon[i] = tmp[i];\n    }\n}\n\n/**\n * Check if a point in the polygon is a reflex point\n * @method isReflex\n * @param  {Number}  i\n * @return {Boolean}\n */\nfunction polygonIsReflex(polygon, i){\n    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\n\nvar tmpLine1=[],\n    tmpLine2=[];\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee(polygon, a,b) {\n    var p, dist, l1=tmpLine1, l2=tmpLine2;\n\n    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n        return false;\n    }\n    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n    for (var i = 0; i !== polygon.length; ++i) { // for each edge\n        if ((i + 1) % polygon.length === a || i === a){ // ignore incident edges\n            continue;\n        }\n        if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) { // if diag intersects an edge\n            l1[0] = polygonAt(polygon, a);\n            l1[1] = polygonAt(polygon, b);\n            l2[0] = polygonAt(polygon, i);\n            l2[1] = polygonAt(polygon, i + 1);\n            p = lineInt(l1,l2);\n            if (sqdist(polygonAt(polygon, a), p) < dist) { // if edge is blocking visibility to b\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n/**\n * Check if two vertices in the polygon can see each other\n * @method canSee2\n * @param  {Number} a Vertex index 1\n * @param  {Number} b Vertex index 2\n * @return {Boolean}\n */\nfunction polygonCanSee2(polygon, a,b) {\n    // for each edge\n    for (var i = 0; i !== polygon.length; ++i) {\n        // ignore incident edges\n        if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b){\n            continue;\n        }\n        if( lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i+1)) ){\n            return false;\n        }\n    }\n    return true;\n}\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @method copy\n * @param  {Number} i\n * @param  {Number} j\n * @param  {Polygon} [targetPoly]   Optional target polygon to save in.\n * @return {Polygon}                The resulting copy.\n */\nfunction polygonCopy(polygon, i,j,targetPoly){\n    var p = targetPoly || [];\n    polygonClear(p);\n    if (i < j) {\n        // Insert all vertices from i to j\n        for(var k=i; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n    } else {\n\n        // Insert vertices 0 to j\n        for(var k=0; k<=j; k++){\n            p.push(polygon[k]);\n        }\n\n        // Insert vertices i to end\n        for(var k=i; k<polygon.length; k++){\n            p.push(polygon[k]);\n        }\n    }\n\n    return p;\n}\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @method getCutEdges\n * @return {Array}\n */\nfunction polygonGetCutEdges(polygon) {\n    var min=[], tmp1=[], tmp2=[], tmpPoly = [];\n    var nDiags = Number.MAX_VALUE;\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(polygon, i)) {\n            for (var j = 0; j < polygon.length; ++j) {\n                if (polygonCanSee(polygon, i, j)) {\n                    tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n                    tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n\n                    for(var k=0; k<tmp2.length; k++){\n                        tmp1.push(tmp2[k]);\n                    }\n\n                    if (tmp1.length < nDiags) {\n                        min = tmp1;\n                        nDiags = tmp1.length;\n                        min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n                    }\n                }\n            }\n        }\n    }\n\n    return min;\n}\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @method decomp\n * @return {Array} An array or Polygon objects.\n */\nfunction polygonDecomp(polygon){\n    var edges = polygonGetCutEdges(polygon);\n    if(edges.length > 0){\n        return polygonSlice(polygon, edges);\n    } else {\n        return [polygon];\n    }\n}\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @method slice\n * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()\n * @return {Array}\n */\nfunction polygonSlice(polygon, cutEdges){\n    if(cutEdges.length === 0){\n\t\treturn [polygon];\n    }\n    if(cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length===2 && cutEdges[0][0] instanceof Array){\n\n        var polys = [polygon];\n\n        for(var i=0; i<cutEdges.length; i++){\n            var cutEdge = cutEdges[i];\n            // Cut all polys\n            for(var j=0; j<polys.length; j++){\n                var poly = polys[j];\n                var result = polygonSlice(poly, cutEdge);\n                if(result){\n                    // Found poly! Cut and quit\n                    polys.splice(j,1);\n                    polys.push(result[0],result[1]);\n                    break;\n                }\n            }\n        }\n\n        return polys;\n    } else {\n\n        // Was given one edge\n        var cutEdge = cutEdges;\n        var i = polygon.indexOf(cutEdge[0]);\n        var j = polygon.indexOf(cutEdge[1]);\n\n        if(i !== -1 && j !== -1){\n            return [polygonCopy(polygon, i,j),\n                    polygonCopy(polygon, j,i)];\n        } else {\n            return false;\n        }\n    }\n}\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @method isSimple\n * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]\n * @return {Boolean}\n * @todo Should it check all segments with all others?\n */\nfunction polygonIsSimple(polygon){\n    var path = polygon, i;\n    // Check\n    for(i=0; i<path.length-1; i++){\n        for(var j=0; j<i-1; j++){\n            if(lineSegmentsIntersect(path[i], path[i+1], path[j], path[j+1] )){\n                return false;\n            }\n        }\n    }\n\n    // Check the segment between the last and the first point to all others\n    for(i=1; i<path.length-2; i++){\n        if(lineSegmentsIntersect(path[0], path[path.length-1], path[i], path[i+1] )){\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getIntersectionPoint(p1, p2, q1, q2, delta){\n\tdelta = delta || 0;\n\tvar a1 = p2[1] - p1[1];\n\tvar b1 = p1[0] - p2[0];\n\tvar c1 = (a1 * p1[0]) + (b1 * p1[1]);\n\tvar a2 = q2[1] - q1[1];\n\tvar b2 = q1[0] - q2[0];\n\tvar c2 = (a2 * q1[0]) + (b2 * q1[1]);\n\tvar det = (a1 * b2) - (a2 * b1);\n\n\tif(!scalar_eq(det,0,delta)){\n\t\treturn [((b2 * c1) - (b1 * c2)) / det, ((a1 * c2) - (a2 * c1)) / det];\n\t} else {\n\t\treturn [0,0];\n    }\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @method quickDecomp\n * @param  {Array} result\n * @param  {Array} [reflexVertices]\n * @param  {Array} [steinerPoints]\n * @param  {Number} [delta]\n * @param  {Number} [maxlevel]\n * @param  {Number} [level]\n * @return {Array}\n */\nfunction polygonQuickDecomp(polygon, result,reflexVertices,steinerPoints,delta,maxlevel,level){\n    maxlevel = maxlevel || 100;\n    level = level || 0;\n    delta = delta || 25;\n    result = typeof(result)!==\"undefined\" ? result : [];\n    reflexVertices = reflexVertices || [];\n    steinerPoints = steinerPoints || [];\n\n    var upperInt=[0,0], lowerInt=[0,0], p=[0,0]; // Points\n    var upperDist=0, lowerDist=0, d=0, closestDist=0; // scalars\n    var upperIndex=0, lowerIndex=0, closestIndex=0; // Integers\n    var lowerPoly=[], upperPoly=[]; // polygons\n    var poly = polygon,\n        v = polygon;\n\n    if(v.length < 3){\n\t\treturn result;\n    }\n\n    level++;\n    if(level > maxlevel){\n        console.warn(\"quickDecomp: max level (\"+maxlevel+\") reached.\");\n        return result;\n    }\n\n    for (var i = 0; i < polygon.length; ++i) {\n        if (polygonIsReflex(poly, i)) {\n            reflexVertices.push(poly[i]);\n            upperDist = lowerDist = Number.MAX_VALUE;\n\n\n            for (var j = 0; j < polygon.length; ++j) {\n                if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) { // if line intersects with an edge\n                    p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n                    if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) { // make sure it's inside the poly\n                        d = sqdist(poly[i], p);\n                        if (d < lowerDist) { // keep only the closest intersection\n                            lowerDist = d;\n                            lowerInt = p;\n                            lowerIndex = j;\n                        }\n                    }\n                }\n                if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n                    p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n                    if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n                        d = sqdist(poly[i], p);\n                        if (d < upperDist) {\n                            upperDist = d;\n                            upperInt = p;\n                            upperIndex = j;\n                        }\n                    }\n                }\n            }\n\n            // if there are no vertices to connect to, choose a point in the middle\n            if (lowerIndex === (upperIndex + 1) % polygon.length) {\n                //console.log(\"Case 1: Vertex(\"+i+\"), lowerIndex(\"+lowerIndex+\"), upperIndex(\"+upperIndex+\"), poly.size(\"+polygon.length+\")\");\n                p[0] = (lowerInt[0] + upperInt[0]) / 2;\n                p[1] = (lowerInt[1] + upperInt[1]) / 2;\n                steinerPoints.push(p);\n\n                if (i < upperIndex) {\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly, i, upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    if (lowerIndex !== 0){\n                        //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());\n                        polygonAppend(upperPoly, poly,lowerIndex,poly.length);\n                    }\n                    //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());\n                        polygonAppend(lowerPoly, poly,i,poly.length);\n                    }\n                    //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);\n                    polygonAppend(lowerPoly, poly,0,upperIndex+1);\n                    lowerPoly.push(p);\n                    upperPoly.push(p);\n                    //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);\n                    polygonAppend(upperPoly, poly,lowerIndex,i+1);\n                }\n            } else {\n                // connect to the closest point within the triangle\n                //console.log(\"Case 2: Vertex(\"+i+\"), closestIndex(\"+closestIndex+\"), poly.size(\"+polygon.length+\")\\n\");\n\n                if (lowerIndex > upperIndex) {\n                    upperIndex += polygon.length;\n                }\n                closestDist = Number.MAX_VALUE;\n\n                if(upperIndex < lowerIndex){\n                    return result;\n                }\n\n                for (var j = lowerIndex; j <= upperIndex; ++j) {\n                    if (\n                        isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) &&\n                        isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))\n                    ) {\n                        d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n                        if (d < closestDist && polygonCanSee2(poly, i, j)) {\n                            closestDist = d;\n                            closestIndex = j % polygon.length;\n                        }\n                    }\n                }\n\n                if (i < closestIndex) {\n                    polygonAppend(lowerPoly, poly,i,closestIndex+1);\n                    if (closestIndex !== 0){\n                        polygonAppend(upperPoly, poly,closestIndex,v.length);\n                    }\n                    polygonAppend(upperPoly, poly,0,i+1);\n                } else {\n                    if (i !== 0){\n                        polygonAppend(lowerPoly, poly,i,v.length);\n                    }\n                    polygonAppend(lowerPoly, poly,0,closestIndex+1);\n                    polygonAppend(upperPoly, poly,closestIndex,i+1);\n                }\n            }\n\n            // solve smallest poly first\n            if (lowerPoly.length < upperPoly.length) {\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            } else {\n                polygonQuickDecomp(upperPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n                polygonQuickDecomp(lowerPoly,result,reflexVertices,steinerPoints,delta,maxlevel,level);\n            }\n\n            return result;\n        }\n    }\n    result.push(polygon);\n\n    return result;\n}\n\n/**\n * Remove collinear points in the polygon.\n * @method removeCollinearPoints\n * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return {Number}           The number of points removed\n */\nfunction polygonRemoveCollinearPoints(polygon, precision){\n    var num = 0;\n    for(var i=polygon.length-1; polygon.length>3 && i>=0; --i){\n        if(collinear(polygonAt(polygon, i-1),polygonAt(polygon, i),polygonAt(polygon, i+1),precision)){\n            // Remove the middle point\n            polygon.splice(i%polygon.length,1);\n            num++;\n        }\n    }\n    return num;\n}\n\n/**\n * Remove duplicate points in the polygon.\n * @method removeDuplicatePoints\n * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.\n */\nfunction polygonRemoveDuplicatePoints(polygon, precision){\n    for(var i=polygon.length-1; i>=1; --i){\n        var pi = polygon[i];\n        for(var j=i-1; j>=0; --j){\n            if(points_eq(pi, polygon[j], precision)){\n                polygon.splice(i,1);\n                continue;\n            }\n        }\n    }\n}\n\n/**\n * Check if two scalars are equal\n * @static\n * @method eq\n * @param  {Number} a\n * @param  {Number} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction scalar_eq(a,b,precision){\n    precision = precision || 0;\n    return Math.abs(a-b) <= precision;\n}\n\n/**\n * Check if two points are equal\n * @static\n * @method points_eq\n * @param  {Array} a\n * @param  {Array} b\n * @param  {Number} [precision]\n * @return {Boolean}\n */\nfunction points_eq(a,b,precision){\n    return scalar_eq(a[0],b[0],precision) && scalar_eq(a[1],b[1],precision);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}