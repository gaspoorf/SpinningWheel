{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Polygon = exports.isSimple = void 0;\nconst poly_decomp_1 = require(\"poly-decomp\");\nObject.defineProperty(exports, \"isSimple\", {\n  enumerable: true,\n  get: function () {\n    return poly_decomp_1.isSimple;\n  }\n});\nconst sat_1 = require(\"sat\");\nconst model_1 = require(\"../model\");\nconst optimized_1 = require(\"../optimized\");\nconst utils_1 = require(\"../utils\");\n/**\n * collider - polygon\n */\nclass Polygon extends sat_1.Polygon {\n  /**\n   * collider - polygon\n   */\n  constructor(position, points, options) {\n    super((0, utils_1.ensureVectorPoint)(position), (0, utils_1.ensurePolygonPoints)(points));\n    /**\n     * was the polygon modified and needs update in the next checkCollision\n     */\n    this.dirty = false;\n    /**\n     * type of body\n     */\n    this.type = model_1.BodyType.Polygon;\n    /**\n     * is body centered\n     */\n    this.centered = false;\n    /**\n     * scale Vector of body\n     */\n    this.scaleVector = {\n      x: 1,\n      y: 1\n    };\n    if (!points.length) {\n      throw new Error(\"No points in polygon\");\n    }\n    (0, utils_1.extendBody)(this, options);\n  }\n  /**\n   * flag to set is polygon centered\n   */\n  set isCentered(isCentered) {\n    if (this.centered === isCentered) {\n      return;\n    }\n    const centroid = this.getCentroidWithoutRotation();\n    const x = centroid.x * (isCentered ? 1 : -1);\n    const y = centroid.y * (isCentered ? 1 : -1);\n    this.translate(-x, -y);\n    this.centered = isCentered;\n  }\n  /**\n   * is polygon centered?\n   */\n  get isCentered() {\n    return this.centered;\n  }\n  get x() {\n    return this.pos.x;\n  }\n  /**\n   * updating this.pos.x by this.x = x updates AABB\n   */\n  set x(x) {\n    this.pos.x = x;\n    this.markAsDirty();\n  }\n  get y() {\n    return this.pos.y;\n  }\n  /**\n   * updating this.pos.y by this.y = y updates AABB\n   */\n  set y(y) {\n    this.pos.y = y;\n    this.markAsDirty();\n  }\n  /**\n   * allow exact getting of scale x - use setScale(x, y) to set\n   */\n  get scaleX() {\n    return this.scaleVector.x;\n  }\n  /**\n   * allow exact getting of scale y - use setScale(x, y) to set\n   */\n  get scaleY() {\n    return this.scaleVector.y;\n  }\n  /**\n   * allow approx getting of scale\n   */\n  get scale() {\n    return (this.scaleVector.x + this.scaleVector.y) / 2;\n  }\n  /**\n   * allow easier setting of scale\n   */\n  set scale(scale) {\n    this.setScale(scale);\n  }\n  /**\n   * update position\n   */\n  setPosition(x, y, update = true) {\n    this.pos.x = x;\n    this.pos.y = y;\n    this.markAsDirty(update);\n    return this;\n  }\n  /**\n   * update scale\n   */\n  setScale(x, y = x, update = true) {\n    this.scaleVector.x = Math.abs(x);\n    this.scaleVector.y = Math.abs(y);\n    super.setPoints((0, optimized_1.map)(this.points, (point, index) => {\n      point.x = this.pointsBackup[index].x * this.scaleVector.x;\n      point.y = this.pointsBackup[index].y * this.scaleVector.y;\n      return point;\n    }));\n    this.markAsDirty(update);\n    return this;\n  }\n  setAngle(angle, update = true) {\n    super.setAngle(angle);\n    this.markAsDirty(update);\n    return this;\n  }\n  setOffset(offset, update = true) {\n    super.setOffset(offset);\n    this.markAsDirty(update);\n    return this;\n  }\n  /**\n   * get body bounding box, without padding\n   */\n  getAABBAsBBox() {\n    const {\n      pos,\n      w,\n      h\n    } = this.getAABBAsBox();\n    return {\n      minX: pos.x,\n      minY: pos.y,\n      maxX: pos.x + w,\n      maxY: pos.y + h\n    };\n  }\n  /**\n   * Draws exact collider on canvas context\n   */\n  draw(context) {\n    (0, utils_1.drawPolygon)(context, this, this.isTrigger);\n  }\n  /**\n   * Draws Bounding Box on canvas context\n   */\n  drawBVH(context) {\n    (0, utils_1.drawBVH)(context, this);\n  }\n  /**\n   * get body centroid without applied angle\n   */\n  getCentroidWithoutRotation() {\n    // keep angle copy\n    const angle = this.angle;\n    // reset angle for get centroid\n    this.setAngle(0);\n    // get centroid\n    const centroid = this.getCentroid();\n    // revert angle change\n    this.setAngle(angle);\n    return centroid;\n  }\n  /**\n   * sets polygon points to new array of vectors\n   */\n  setPoints(points) {\n    super.setPoints(points);\n    this.updateIsConvex();\n    this.pointsBackup = (0, utils_1.clonePointsArray)(points);\n    return this;\n  }\n  /**\n   * translates polygon points in x, y direction\n   */\n  translate(x, y) {\n    super.translate(x, y);\n    this.pointsBackup = (0, utils_1.clonePointsArray)(this.points);\n    return this;\n  }\n  /**\n   * rotates polygon points by angle, in radians\n   */\n  rotate(angle) {\n    super.rotate(angle);\n    this.pointsBackup = (0, utils_1.clonePointsArray)(this.points);\n    return this;\n  }\n  /**\n   * if true, polygon is not an invalid, self-crossing polygon\n   */\n  isSimple() {\n    return (0, poly_decomp_1.isSimple)(this.calcPoints.map(utils_1.mapVectorToArray));\n  }\n  /**\n   * inner function for after position change update aabb in system and convex inner polygons\n   */\n  updateBody(update = this.dirty) {\n    var _a;\n    if (update) {\n      this.updateConvexPolygonPositions();\n      (_a = this.system) === null || _a === void 0 ? void 0 : _a.insert(this);\n      this.dirty = false;\n    }\n  }\n  /**\n   * update instantly or mark as dirty\n   */\n  markAsDirty(update = false) {\n    if (update) {\n      this.updateBody(true);\n    } else {\n      this.dirty = true;\n    }\n  }\n  /**\n   * update the position of the decomposed convex polygons (if any), called\n   * after the position of the body has changed\n   */\n  updateConvexPolygonPositions() {\n    if (this.isConvex || !this.convexPolygons) {\n      return;\n    }\n    (0, optimized_1.forEach)(this.convexPolygons, polygon => {\n      polygon.pos.x = this.pos.x;\n      polygon.pos.y = this.pos.y;\n    });\n  }\n  /**\n   * returns body split into convex polygons, or empty array for convex bodies\n   */\n  getConvex() {\n    if (this.type && this.type !== model_1.BodyType.Polygon || this.points.length < 4) {\n      return [];\n    }\n    const points = (0, optimized_1.map)(this.calcPoints, utils_1.mapVectorToArray);\n    return (0, poly_decomp_1.quickDecomp)(points);\n  }\n  /**\n   * updates convex polygons cache in body\n   */\n  updateConvexPolygons(convex = this.getConvex()) {\n    if (this.isConvex) {\n      return;\n    }\n    if (!this.convexPolygons) {\n      this.convexPolygons = [];\n    }\n    (0, optimized_1.forEach)(convex, (points, index) => {\n      // lazy create\n      if (!this.convexPolygons[index]) {\n        this.convexPolygons[index] = new sat_1.Polygon();\n      }\n      this.convexPolygons[index].pos.x = this.pos.x;\n      this.convexPolygons[index].pos.y = this.pos.y;\n      this.convexPolygons[index].setPoints((0, utils_1.ensurePolygonPoints)((0, optimized_1.map)(points, utils_1.mapArrayToVector)));\n    });\n    // trim array length\n    this.convexPolygons.length = convex.length;\n  }\n  /**\n   * after points update set is convex\n   */\n  updateIsConvex() {\n    // all other types other than polygon are always convex\n    const convex = this.getConvex();\n    // everything with empty array or one element array\n    this.isConvex = convex.length <= 1;\n    this.updateConvexPolygons(convex);\n  }\n}\nexports.Polygon = Polygon;","map":{"version":3,"names":["Object","defineProperty","exports","value","Polygon","isSimple","poly_decomp_1","require","enumerable","get","sat_1","model_1","optimized_1","utils_1","constructor","position","points","options","ensureVectorPoint","ensurePolygonPoints","dirty","type","BodyType","centered","scaleVector","x","y","length","Error","extendBody","isCentered","centroid","getCentroidWithoutRotation","translate","pos","markAsDirty","scaleX","scaleY","scale","setScale","setPosition","update","Math","abs","setPoints","map","point","index","pointsBackup","setAngle","angle","setOffset","offset","getAABBAsBBox","w","h","getAABBAsBox","minX","minY","maxX","maxY","draw","context","drawPolygon","isTrigger","drawBVH","getCentroid","updateIsConvex","clonePointsArray","rotate","calcPoints","mapVectorToArray","updateBody","_a","updateConvexPolygonPositions","system","insert","isConvex","convexPolygons","forEach","polygon","getConvex","quickDecomp","updateConvexPolygons","convex","mapArrayToVector"],"sources":["C:/Users/gaspa/OneDrive/Documents/MMI 2/S4/React/SpinningWheel/spin-wheel/node_modules/detect-collisions/dist/bodies/polygon.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Polygon = exports.isSimple = void 0;\nconst poly_decomp_1 = require(\"poly-decomp\");\nObject.defineProperty(exports, \"isSimple\", { enumerable: true, get: function () { return poly_decomp_1.isSimple; } });\nconst sat_1 = require(\"sat\");\nconst model_1 = require(\"../model\");\nconst optimized_1 = require(\"../optimized\");\nconst utils_1 = require(\"../utils\");\n/**\n * collider - polygon\n */\nclass Polygon extends sat_1.Polygon {\n    /**\n     * collider - polygon\n     */\n    constructor(position, points, options) {\n        super((0, utils_1.ensureVectorPoint)(position), (0, utils_1.ensurePolygonPoints)(points));\n        /**\n         * was the polygon modified and needs update in the next checkCollision\n         */\n        this.dirty = false;\n        /**\n         * type of body\n         */\n        this.type = model_1.BodyType.Polygon;\n        /**\n         * is body centered\n         */\n        this.centered = false;\n        /**\n         * scale Vector of body\n         */\n        this.scaleVector = { x: 1, y: 1 };\n        if (!points.length) {\n            throw new Error(\"No points in polygon\");\n        }\n        (0, utils_1.extendBody)(this, options);\n    }\n    /**\n     * flag to set is polygon centered\n     */\n    set isCentered(isCentered) {\n        if (this.centered === isCentered) {\n            return;\n        }\n        const centroid = this.getCentroidWithoutRotation();\n        const x = centroid.x * (isCentered ? 1 : -1);\n        const y = centroid.y * (isCentered ? 1 : -1);\n        this.translate(-x, -y);\n        this.centered = isCentered;\n    }\n    /**\n     * is polygon centered?\n     */\n    get isCentered() {\n        return this.centered;\n    }\n    get x() {\n        return this.pos.x;\n    }\n    /**\n     * updating this.pos.x by this.x = x updates AABB\n     */\n    set x(x) {\n        this.pos.x = x;\n        this.markAsDirty();\n    }\n    get y() {\n        return this.pos.y;\n    }\n    /**\n     * updating this.pos.y by this.y = y updates AABB\n     */\n    set y(y) {\n        this.pos.y = y;\n        this.markAsDirty();\n    }\n    /**\n     * allow exact getting of scale x - use setScale(x, y) to set\n     */\n    get scaleX() {\n        return this.scaleVector.x;\n    }\n    /**\n     * allow exact getting of scale y - use setScale(x, y) to set\n     */\n    get scaleY() {\n        return this.scaleVector.y;\n    }\n    /**\n     * allow approx getting of scale\n     */\n    get scale() {\n        return (this.scaleVector.x + this.scaleVector.y) / 2;\n    }\n    /**\n     * allow easier setting of scale\n     */\n    set scale(scale) {\n        this.setScale(scale);\n    }\n    /**\n     * update position\n     */\n    setPosition(x, y, update = true) {\n        this.pos.x = x;\n        this.pos.y = y;\n        this.markAsDirty(update);\n        return this;\n    }\n    /**\n     * update scale\n     */\n    setScale(x, y = x, update = true) {\n        this.scaleVector.x = Math.abs(x);\n        this.scaleVector.y = Math.abs(y);\n        super.setPoints((0, optimized_1.map)(this.points, (point, index) => {\n            point.x = this.pointsBackup[index].x * this.scaleVector.x;\n            point.y = this.pointsBackup[index].y * this.scaleVector.y;\n            return point;\n        }));\n        this.markAsDirty(update);\n        return this;\n    }\n    setAngle(angle, update = true) {\n        super.setAngle(angle);\n        this.markAsDirty(update);\n        return this;\n    }\n    setOffset(offset, update = true) {\n        super.setOffset(offset);\n        this.markAsDirty(update);\n        return this;\n    }\n    /**\n     * get body bounding box, without padding\n     */\n    getAABBAsBBox() {\n        const { pos, w, h } = this.getAABBAsBox();\n        return {\n            minX: pos.x,\n            minY: pos.y,\n            maxX: pos.x + w,\n            maxY: pos.y + h,\n        };\n    }\n    /**\n     * Draws exact collider on canvas context\n     */\n    draw(context) {\n        (0, utils_1.drawPolygon)(context, this, this.isTrigger);\n    }\n    /**\n     * Draws Bounding Box on canvas context\n     */\n    drawBVH(context) {\n        (0, utils_1.drawBVH)(context, this);\n    }\n    /**\n     * get body centroid without applied angle\n     */\n    getCentroidWithoutRotation() {\n        // keep angle copy\n        const angle = this.angle;\n        // reset angle for get centroid\n        this.setAngle(0);\n        // get centroid\n        const centroid = this.getCentroid();\n        // revert angle change\n        this.setAngle(angle);\n        return centroid;\n    }\n    /**\n     * sets polygon points to new array of vectors\n     */\n    setPoints(points) {\n        super.setPoints(points);\n        this.updateIsConvex();\n        this.pointsBackup = (0, utils_1.clonePointsArray)(points);\n        return this;\n    }\n    /**\n     * translates polygon points in x, y direction\n     */\n    translate(x, y) {\n        super.translate(x, y);\n        this.pointsBackup = (0, utils_1.clonePointsArray)(this.points);\n        return this;\n    }\n    /**\n     * rotates polygon points by angle, in radians\n     */\n    rotate(angle) {\n        super.rotate(angle);\n        this.pointsBackup = (0, utils_1.clonePointsArray)(this.points);\n        return this;\n    }\n    /**\n     * if true, polygon is not an invalid, self-crossing polygon\n     */\n    isSimple() {\n        return (0, poly_decomp_1.isSimple)(this.calcPoints.map(utils_1.mapVectorToArray));\n    }\n    /**\n     * inner function for after position change update aabb in system and convex inner polygons\n     */\n    updateBody(update = this.dirty) {\n        var _a;\n        if (update) {\n            this.updateConvexPolygonPositions();\n            (_a = this.system) === null || _a === void 0 ? void 0 : _a.insert(this);\n            this.dirty = false;\n        }\n    }\n    /**\n     * update instantly or mark as dirty\n     */\n    markAsDirty(update = false) {\n        if (update) {\n            this.updateBody(true);\n        }\n        else {\n            this.dirty = true;\n        }\n    }\n    /**\n     * update the position of the decomposed convex polygons (if any), called\n     * after the position of the body has changed\n     */\n    updateConvexPolygonPositions() {\n        if (this.isConvex || !this.convexPolygons) {\n            return;\n        }\n        (0, optimized_1.forEach)(this.convexPolygons, (polygon) => {\n            polygon.pos.x = this.pos.x;\n            polygon.pos.y = this.pos.y;\n        });\n    }\n    /**\n     * returns body split into convex polygons, or empty array for convex bodies\n     */\n    getConvex() {\n        if ((this.type && this.type !== model_1.BodyType.Polygon) ||\n            this.points.length < 4) {\n            return [];\n        }\n        const points = (0, optimized_1.map)(this.calcPoints, utils_1.mapVectorToArray);\n        return (0, poly_decomp_1.quickDecomp)(points);\n    }\n    /**\n     * updates convex polygons cache in body\n     */\n    updateConvexPolygons(convex = this.getConvex()) {\n        if (this.isConvex) {\n            return;\n        }\n        if (!this.convexPolygons) {\n            this.convexPolygons = [];\n        }\n        (0, optimized_1.forEach)(convex, (points, index) => {\n            // lazy create\n            if (!this.convexPolygons[index]) {\n                this.convexPolygons[index] = new sat_1.Polygon();\n            }\n            this.convexPolygons[index].pos.x = this.pos.x;\n            this.convexPolygons[index].pos.y = this.pos.y;\n            this.convexPolygons[index].setPoints((0, utils_1.ensurePolygonPoints)((0, optimized_1.map)(points, utils_1.mapArrayToVector)));\n        });\n        // trim array length\n        this.convexPolygons.length = convex.length;\n    }\n    /**\n     * after points update set is convex\n     */\n    updateIsConvex() {\n        // all other types other than polygon are always convex\n        const convex = this.getConvex();\n        // everything with empty array or one element array\n        this.isConvex = convex.length <= 1;\n        this.updateConvexPolygons(convex);\n    }\n}\nexports.Polygon = Polygon;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,OAAO,GAAGF,OAAO,CAACG,QAAQ,GAAG,KAAK,CAAC;AAC3C,MAAMC,aAAa,GAAGC,OAAO,CAAC,aAAa,CAAC;AAC5CP,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,UAAU,EAAE;EAAEM,UAAU,EAAE,IAAI;EAAEC,GAAG,EAAE,SAAAA,CAAA,EAAY;IAAE,OAAOH,aAAa,CAACD,QAAQ;EAAE;AAAE,CAAC,CAAC;AACrH,MAAMK,KAAK,GAAGH,OAAO,CAAC,KAAK,CAAC;AAC5B,MAAMI,OAAO,GAAGJ,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMK,WAAW,GAAGL,OAAO,CAAC,cAAc,CAAC;AAC3C,MAAMM,OAAO,GAAGN,OAAO,CAAC,UAAU,CAAC;AACnC;AACA;AACA;AACA,MAAMH,OAAO,SAASM,KAAK,CAACN,OAAO,CAAC;EAChC;AACJ;AACA;EACIU,WAAWA,CAACC,QAAQ,EAAEC,MAAM,EAAEC,OAAO,EAAE;IACnC,KAAK,CAAC,CAAC,CAAC,EAAEJ,OAAO,CAACK,iBAAiB,EAAEH,QAAQ,CAAC,EAAE,CAAC,CAAC,EAAEF,OAAO,CAACM,mBAAmB,EAAEH,MAAM,CAAC,CAAC;IACzF;AACR;AACA;IACQ,IAAI,CAACI,KAAK,GAAG,KAAK;IAClB;AACR;AACA;IACQ,IAAI,CAACC,IAAI,GAAGV,OAAO,CAACW,QAAQ,CAAClB,OAAO;IACpC;AACR;AACA;IACQ,IAAI,CAACmB,QAAQ,GAAG,KAAK;IACrB;AACR;AACA;IACQ,IAAI,CAACC,WAAW,GAAG;MAAEC,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;IACjC,IAAI,CAACV,MAAM,CAACW,MAAM,EAAE;MAChB,MAAM,IAAIC,KAAK,CAAC,sBAAsB,CAAC;IAC3C;IACA,CAAC,CAAC,EAAEf,OAAO,CAACgB,UAAU,EAAE,IAAI,EAAEZ,OAAO,CAAC;EAC1C;EACA;AACJ;AACA;EACI,IAAIa,UAAUA,CAACA,UAAU,EAAE;IACvB,IAAI,IAAI,CAACP,QAAQ,KAAKO,UAAU,EAAE;MAC9B;IACJ;IACA,MAAMC,QAAQ,GAAG,IAAI,CAACC,0BAA0B,CAAC,CAAC;IAClD,MAAMP,CAAC,GAAGM,QAAQ,CAACN,CAAC,IAAIK,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IAC5C,MAAMJ,CAAC,GAAGK,QAAQ,CAACL,CAAC,IAAII,UAAU,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC;IAC5C,IAAI,CAACG,SAAS,CAAC,CAACR,CAAC,EAAE,CAACC,CAAC,CAAC;IACtB,IAAI,CAACH,QAAQ,GAAGO,UAAU;EAC9B;EACA;AACJ;AACA;EACI,IAAIA,UAAUA,CAAA,EAAG;IACb,OAAO,IAAI,CAACP,QAAQ;EACxB;EACA,IAAIE,CAACA,CAAA,EAAG;IACJ,OAAO,IAAI,CAACS,GAAG,CAACT,CAAC;EACrB;EACA;AACJ;AACA;EACI,IAAIA,CAACA,CAACA,CAAC,EAAE;IACL,IAAI,CAACS,GAAG,CAACT,CAAC,GAAGA,CAAC;IACd,IAAI,CAACU,WAAW,CAAC,CAAC;EACtB;EACA,IAAIT,CAACA,CAAA,EAAG;IACJ,OAAO,IAAI,CAACQ,GAAG,CAACR,CAAC;EACrB;EACA;AACJ;AACA;EACI,IAAIA,CAACA,CAACA,CAAC,EAAE;IACL,IAAI,CAACQ,GAAG,CAACR,CAAC,GAAGA,CAAC;IACd,IAAI,CAACS,WAAW,CAAC,CAAC;EACtB;EACA;AACJ;AACA;EACI,IAAIC,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAACZ,WAAW,CAACC,CAAC;EAC7B;EACA;AACJ;AACA;EACI,IAAIY,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAACb,WAAW,CAACE,CAAC;EAC7B;EACA;AACJ;AACA;EACI,IAAIY,KAAKA,CAAA,EAAG;IACR,OAAO,CAAC,IAAI,CAACd,WAAW,CAACC,CAAC,GAAG,IAAI,CAACD,WAAW,CAACE,CAAC,IAAI,CAAC;EACxD;EACA;AACJ;AACA;EACI,IAAIY,KAAKA,CAACA,KAAK,EAAE;IACb,IAAI,CAACC,QAAQ,CAACD,KAAK,CAAC;EACxB;EACA;AACJ;AACA;EACIE,WAAWA,CAACf,CAAC,EAAEC,CAAC,EAAEe,MAAM,GAAG,IAAI,EAAE;IAC7B,IAAI,CAACP,GAAG,CAACT,CAAC,GAAGA,CAAC;IACd,IAAI,CAACS,GAAG,CAACR,CAAC,GAAGA,CAAC;IACd,IAAI,CAACS,WAAW,CAACM,MAAM,CAAC;IACxB,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIF,QAAQA,CAACd,CAAC,EAAEC,CAAC,GAAGD,CAAC,EAAEgB,MAAM,GAAG,IAAI,EAAE;IAC9B,IAAI,CAACjB,WAAW,CAACC,CAAC,GAAGiB,IAAI,CAACC,GAAG,CAAClB,CAAC,CAAC;IAChC,IAAI,CAACD,WAAW,CAACE,CAAC,GAAGgB,IAAI,CAACC,GAAG,CAACjB,CAAC,CAAC;IAChC,KAAK,CAACkB,SAAS,CAAC,CAAC,CAAC,EAAEhC,WAAW,CAACiC,GAAG,EAAE,IAAI,CAAC7B,MAAM,EAAE,CAAC8B,KAAK,EAAEC,KAAK,KAAK;MAChED,KAAK,CAACrB,CAAC,GAAG,IAAI,CAACuB,YAAY,CAACD,KAAK,CAAC,CAACtB,CAAC,GAAG,IAAI,CAACD,WAAW,CAACC,CAAC;MACzDqB,KAAK,CAACpB,CAAC,GAAG,IAAI,CAACsB,YAAY,CAACD,KAAK,CAAC,CAACrB,CAAC,GAAG,IAAI,CAACF,WAAW,CAACE,CAAC;MACzD,OAAOoB,KAAK;IAChB,CAAC,CAAC,CAAC;IACH,IAAI,CAACX,WAAW,CAACM,MAAM,CAAC;IACxB,OAAO,IAAI;EACf;EACAQ,QAAQA,CAACC,KAAK,EAAET,MAAM,GAAG,IAAI,EAAE;IAC3B,KAAK,CAACQ,QAAQ,CAACC,KAAK,CAAC;IACrB,IAAI,CAACf,WAAW,CAACM,MAAM,CAAC;IACxB,OAAO,IAAI;EACf;EACAU,SAASA,CAACC,MAAM,EAAEX,MAAM,GAAG,IAAI,EAAE;IAC7B,KAAK,CAACU,SAAS,CAACC,MAAM,CAAC;IACvB,IAAI,CAACjB,WAAW,CAACM,MAAM,CAAC;IACxB,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIY,aAAaA,CAAA,EAAG;IACZ,MAAM;MAAEnB,GAAG;MAAEoB,CAAC;MAAEC;IAAE,CAAC,GAAG,IAAI,CAACC,YAAY,CAAC,CAAC;IACzC,OAAO;MACHC,IAAI,EAAEvB,GAAG,CAACT,CAAC;MACXiC,IAAI,EAAExB,GAAG,CAACR,CAAC;MACXiC,IAAI,EAAEzB,GAAG,CAACT,CAAC,GAAG6B,CAAC;MACfM,IAAI,EAAE1B,GAAG,CAACR,CAAC,GAAG6B;IAClB,CAAC;EACL;EACA;AACJ;AACA;EACIM,IAAIA,CAACC,OAAO,EAAE;IACV,CAAC,CAAC,EAAEjD,OAAO,CAACkD,WAAW,EAAED,OAAO,EAAE,IAAI,EAAE,IAAI,CAACE,SAAS,CAAC;EAC3D;EACA;AACJ;AACA;EACIC,OAAOA,CAACH,OAAO,EAAE;IACb,CAAC,CAAC,EAAEjD,OAAO,CAACoD,OAAO,EAAEH,OAAO,EAAE,IAAI,CAAC;EACvC;EACA;AACJ;AACA;EACI9B,0BAA0BA,CAAA,EAAG;IACzB;IACA,MAAMkB,KAAK,GAAG,IAAI,CAACA,KAAK;IACxB;IACA,IAAI,CAACD,QAAQ,CAAC,CAAC,CAAC;IAChB;IACA,MAAMlB,QAAQ,GAAG,IAAI,CAACmC,WAAW,CAAC,CAAC;IACnC;IACA,IAAI,CAACjB,QAAQ,CAACC,KAAK,CAAC;IACpB,OAAOnB,QAAQ;EACnB;EACA;AACJ;AACA;EACIa,SAASA,CAAC5B,MAAM,EAAE;IACd,KAAK,CAAC4B,SAAS,CAAC5B,MAAM,CAAC;IACvB,IAAI,CAACmD,cAAc,CAAC,CAAC;IACrB,IAAI,CAACnB,YAAY,GAAG,CAAC,CAAC,EAAEnC,OAAO,CAACuD,gBAAgB,EAAEpD,MAAM,CAAC;IACzD,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIiB,SAASA,CAACR,CAAC,EAAEC,CAAC,EAAE;IACZ,KAAK,CAACO,SAAS,CAACR,CAAC,EAAEC,CAAC,CAAC;IACrB,IAAI,CAACsB,YAAY,GAAG,CAAC,CAAC,EAAEnC,OAAO,CAACuD,gBAAgB,EAAE,IAAI,CAACpD,MAAM,CAAC;IAC9D,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIqD,MAAMA,CAACnB,KAAK,EAAE;IACV,KAAK,CAACmB,MAAM,CAACnB,KAAK,CAAC;IACnB,IAAI,CAACF,YAAY,GAAG,CAAC,CAAC,EAAEnC,OAAO,CAACuD,gBAAgB,EAAE,IAAI,CAACpD,MAAM,CAAC;IAC9D,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIX,QAAQA,CAAA,EAAG;IACP,OAAO,CAAC,CAAC,EAAEC,aAAa,CAACD,QAAQ,EAAE,IAAI,CAACiE,UAAU,CAACzB,GAAG,CAAChC,OAAO,CAAC0D,gBAAgB,CAAC,CAAC;EACrF;EACA;AACJ;AACA;EACIC,UAAUA,CAAC/B,MAAM,GAAG,IAAI,CAACrB,KAAK,EAAE;IAC5B,IAAIqD,EAAE;IACN,IAAIhC,MAAM,EAAE;MACR,IAAI,CAACiC,4BAA4B,CAAC,CAAC;MACnC,CAACD,EAAE,GAAG,IAAI,CAACE,MAAM,MAAM,IAAI,IAAIF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACG,MAAM,CAAC,IAAI,CAAC;MACvE,IAAI,CAACxD,KAAK,GAAG,KAAK;IACtB;EACJ;EACA;AACJ;AACA;EACIe,WAAWA,CAACM,MAAM,GAAG,KAAK,EAAE;IACxB,IAAIA,MAAM,EAAE;MACR,IAAI,CAAC+B,UAAU,CAAC,IAAI,CAAC;IACzB,CAAC,MACI;MACD,IAAI,CAACpD,KAAK,GAAG,IAAI;IACrB;EACJ;EACA;AACJ;AACA;AACA;EACIsD,4BAA4BA,CAAA,EAAG;IAC3B,IAAI,IAAI,CAACG,QAAQ,IAAI,CAAC,IAAI,CAACC,cAAc,EAAE;MACvC;IACJ;IACA,CAAC,CAAC,EAAElE,WAAW,CAACmE,OAAO,EAAE,IAAI,CAACD,cAAc,EAAGE,OAAO,IAAK;MACvDA,OAAO,CAAC9C,GAAG,CAACT,CAAC,GAAG,IAAI,CAACS,GAAG,CAACT,CAAC;MAC1BuD,OAAO,CAAC9C,GAAG,CAACR,CAAC,GAAG,IAAI,CAACQ,GAAG,CAACR,CAAC;IAC9B,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACIuD,SAASA,CAAA,EAAG;IACR,IAAK,IAAI,CAAC5D,IAAI,IAAI,IAAI,CAACA,IAAI,KAAKV,OAAO,CAACW,QAAQ,CAAClB,OAAO,IACpD,IAAI,CAACY,MAAM,CAACW,MAAM,GAAG,CAAC,EAAE;MACxB,OAAO,EAAE;IACb;IACA,MAAMX,MAAM,GAAG,CAAC,CAAC,EAAEJ,WAAW,CAACiC,GAAG,EAAE,IAAI,CAACyB,UAAU,EAAEzD,OAAO,CAAC0D,gBAAgB,CAAC;IAC9E,OAAO,CAAC,CAAC,EAAEjE,aAAa,CAAC4E,WAAW,EAAElE,MAAM,CAAC;EACjD;EACA;AACJ;AACA;EACImE,oBAAoBA,CAACC,MAAM,GAAG,IAAI,CAACH,SAAS,CAAC,CAAC,EAAE;IAC5C,IAAI,IAAI,CAACJ,QAAQ,EAAE;MACf;IACJ;IACA,IAAI,CAAC,IAAI,CAACC,cAAc,EAAE;MACtB,IAAI,CAACA,cAAc,GAAG,EAAE;IAC5B;IACA,CAAC,CAAC,EAAElE,WAAW,CAACmE,OAAO,EAAEK,MAAM,EAAE,CAACpE,MAAM,EAAE+B,KAAK,KAAK;MAChD;MACA,IAAI,CAAC,IAAI,CAAC+B,cAAc,CAAC/B,KAAK,CAAC,EAAE;QAC7B,IAAI,CAAC+B,cAAc,CAAC/B,KAAK,CAAC,GAAG,IAAIrC,KAAK,CAACN,OAAO,CAAC,CAAC;MACpD;MACA,IAAI,CAAC0E,cAAc,CAAC/B,KAAK,CAAC,CAACb,GAAG,CAACT,CAAC,GAAG,IAAI,CAACS,GAAG,CAACT,CAAC;MAC7C,IAAI,CAACqD,cAAc,CAAC/B,KAAK,CAAC,CAACb,GAAG,CAACR,CAAC,GAAG,IAAI,CAACQ,GAAG,CAACR,CAAC;MAC7C,IAAI,CAACoD,cAAc,CAAC/B,KAAK,CAAC,CAACH,SAAS,CAAC,CAAC,CAAC,EAAE/B,OAAO,CAACM,mBAAmB,EAAE,CAAC,CAAC,EAAEP,WAAW,CAACiC,GAAG,EAAE7B,MAAM,EAAEH,OAAO,CAACwE,gBAAgB,CAAC,CAAC,CAAC;IAClI,CAAC,CAAC;IACF;IACA,IAAI,CAACP,cAAc,CAACnD,MAAM,GAAGyD,MAAM,CAACzD,MAAM;EAC9C;EACA;AACJ;AACA;EACIwC,cAAcA,CAAA,EAAG;IACb;IACA,MAAMiB,MAAM,GAAG,IAAI,CAACH,SAAS,CAAC,CAAC;IAC/B;IACA,IAAI,CAACJ,QAAQ,GAAGO,MAAM,CAACzD,MAAM,IAAI,CAAC;IAClC,IAAI,CAACwD,oBAAoB,CAACC,MAAM,CAAC;EACrC;AACJ;AACAlF,OAAO,CAACE,OAAO,GAAGA,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}