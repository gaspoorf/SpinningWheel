{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\gaspa\\\\OneDrive\\\\Documents\\\\MMI 2\\\\S4\\\\React\\\\SpinningWheel\\\\spin-wheel\\\\src\\\\components\\\\WheelConstructor.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useState } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst WheelComponent = ({\n  segments,\n  segColors,\n  winningSegment,\n  onFinished,\n  onRotate,\n  onRotatefinish,\n  primaryColor,\n  primaryColoraround,\n  contrastColor,\n  buttonText,\n  isOnlyOnce = true,\n  size = 290,\n  upDuration = 1000,\n  downDuration = 100,\n  fontFamily = \"proxima-nova\",\n  width = 100,\n  height = 100\n}) => {\n  _s();\n  let currentSegment = \"\";\n  let isStarted = false;\n  const [isFinished, setFinished] = useState(false);\n  let timerHandle = 0;\n  const timerDelay = segments.length;\n  let angleCurrent = 0;\n  let angleDelta = 0;\n  let canvasContext = null;\n  let maxSpeed = Math.PI / `${segments.length}`;\n  const upTime = segments.length * upDuration;\n  const downTime = segments.length * downDuration;\n  let spinStart = 0;\n  let frames = 0;\n  const centerX = 300;\n  const centerY = 300;\n  useEffect(() => {\n    const rootNode = document.getElementById(\"RootNode\");\n    if (rootNode) {\n      rootNode.onclick = function () {\n        spin();\n      };\n    }\n    const rootNodeRes = document.getElementById(\"RootNodeRes\");\n    if (rootNodeRes) {\n      rootNodeRes.onclick = function () {\n        spin();\n      };\n    }\n    wheelInit();\n    setTimeout(() => {\n      window.scrollTo(0, 1);\n    }, 0);\n  }, []);\n  const wheelInit = () => {\n    initCanvas();\n    wheelDraw();\n  };\n  const initCanvas = () => {\n    let canvas = document.getElementById(\"canvas\");\n    if (navigator.appVersion.indexOf(\"MSIE\") !== -1) {\n      canvas = document.createElement(\"canvas\");\n      canvas.setAttribute(\"width\", width);\n      canvas.setAttribute(\"height\", height);\n      canvas.setAttribute(\"id\", \"canvas\");\n      document.getElementById(\"wheel\").appendChild(canvas);\n    }\n    // canvas.addEventListener(\"click\", spin, false);\n    canvasContext = canvas.getContext(\"2d\");\n  };\n  const spin = () => {\n    isStarted = true;\n    if (timerHandle === 0) {\n      spinStart = new Date().getTime();\n      maxSpeed = Math.PI / segments.length;\n      frames = 0;\n      timerHandle = setInterval(onTimerTick, timerDelay);\n    }\n  };\n  const onTimerTick = () => {\n    frames++;\n    draw();\n    const duration = new Date().getTime() - spinStart;\n    let progress = 0;\n    let finished = false;\n    if (duration < upTime) {\n      progress = duration / upTime;\n      angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2);\n    } else {\n      if (winningSegment) {\n        if (currentSegment === winningSegment && frames > segments.length) {\n          progress = duration / upTime;\n          angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n          progress = 1;\n        } else {\n          progress = duration / downTime;\n          angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n        }\n      } else {\n        progress = duration / downTime;\n        if (progress >= 0.8) {\n          angleDelta = maxSpeed / 1.2 * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n        } else if (progress >= 0.98) {\n          angleDelta = maxSpeed / 2 * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n        } else angleDelta = maxSpeed * Math.sin(progress * Math.PI / 2 + Math.PI / 2);\n      }\n      if (progress >= 1) finished = true;\n    }\n    angleCurrent += angleDelta;\n    while (angleCurrent >= Math.PI * 2) angleCurrent -= Math.PI * 2;\n    if (finished) {\n      setFinished(true);\n      onFinished(currentSegment);\n      clearInterval(timerHandle);\n      timerHandle = 0;\n      angleDelta = 0;\n    }\n  };\n  const wheelDraw = () => {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n  const draw = () => {\n    clear();\n    drawWheel();\n    drawNeedle();\n  };\n  const drawSegment = (key, lastAngle, angle) => {\n    const ctx = canvasContext;\n    const value = segments[key];\n    ctx.save();\n    ctx.beginPath();\n    ctx.moveTo(centerX, centerY);\n    ctx.arc(centerX, centerY, size, lastAngle, angle, false);\n    ctx.lineTo(centerX, centerY);\n    ctx.closePath();\n    ctx.fillStyle = segColors[key];\n    ctx.fill();\n    ctx.stroke();\n    ctx.save();\n    ctx.translate(centerX, centerY);\n    ctx.rotate((lastAngle + angle) / 2);\n    ctx.fillStyle = contrastColor || \"white\";\n    ctx.font = \"bold 1em \" + fontFamily;\n    ctx.fillText(value.substr(0, 21), size / 2 + 20, 0);\n    ctx.restore();\n  };\n  const drawWheel = () => {\n    const ctx = canvasContext;\n    let lastAngle = angleCurrent;\n    const len = segments.length;\n    const PI2 = Math.PI * 2;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = primaryColor || \"black\";\n    ctx.textBaseline = \"middle\";\n    ctx.textAlign = \"center\";\n    ctx.font = \"1em \" + fontFamily;\n    for (let i = 1; i <= len; i++) {\n      const angle = PI2 * (i / len) + angleCurrent;\n      drawSegment(i - 1, lastAngle, angle);\n      lastAngle = angle;\n    }\n\n    // Draw a center circle\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, 40, 0, PI2, false);\n    ctx.closePath();\n    ctx.fillStyle = primaryColor || \"black\";\n    ctx.lineWidth = 5;\n    ctx.strokeStyle = contrastColor || \"white\";\n    ctx.fill();\n    ctx.font = \"bold 2em \" + fontFamily;\n    ctx.fillStyle = contrastColor || \"white\";\n    ctx.textAlign = \"center\";\n    ctx.fillText(buttonText || \"Spin\", centerX, centerY + 3);\n    ctx.stroke();\n\n    // Draw outer circle\n    ctx.beginPath();\n    ctx.arc(centerX, centerY, size, 0, PI2, false);\n    ctx.closePath();\n    ctx.lineWidth = 25;\n    ctx.strokeStyle = primaryColoraround || \"white\";\n    ctx.stroke();\n  };\n  const drawNeedle = () => {\n    const ctx = canvasContext;\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = contrastColor || \"white\";\n    ctx.fileStyle = contrastColor || \"white\";\n    ctx.beginPath();\n    ctx.moveTo(centerX + 10, centerY - 40);\n    ctx.lineTo(centerX - 10, centerY - 40);\n    ctx.lineTo(centerX, centerY - 60);\n    ctx.closePath();\n    ctx.fill();\n    const change = angleCurrent + Math.PI / 2;\n    let i = segments.length - Math.floor(change / (Math.PI * 2) * segments.length) - 1;\n    if (i < 0) i = i + segments.length;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillStyle = \"transparent\";\n    ctx.font = \"bold 1.5em \" + fontFamily;\n    currentSegment = segments[i];\n    isStarted && ctx.fillText(currentSegment, centerX + 10, centerY + size + 50);\n  };\n  const clear = () => {\n    const ctx = canvasContext;\n    ctx.clearRect(0, 0, 1000, 800);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    id: \"wheel\",\n    children: /*#__PURE__*/_jsxDEV(\"canvas\", {\n      id: \"canvas\",\n      width: \"600\",\n      height: \"600\",\n      style: {\n        pointerEvents: isFinished && isOnlyOnce ? \"none\" : \"auto\"\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 236,\n      columnNumber: 13\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 235,\n    columnNumber: 9\n  }, this);\n};\n_s(WheelComponent, \"MpQqlRLvihk1SkKDgJJ1C7OqczQ=\");\n_c = WheelComponent;\nexport default WheelComponent2;\nvar _c;\n$RefreshReg$(_c, \"WheelComponent\");","map":{"version":3,"names":["React","useEffect","useState","jsxDEV","_jsxDEV","WheelComponent","segments","segColors","winningSegment","onFinished","onRotate","onRotatefinish","primaryColor","primaryColoraround","contrastColor","buttonText","isOnlyOnce","size","upDuration","downDuration","fontFamily","width","height","_s","currentSegment","isStarted","isFinished","setFinished","timerHandle","timerDelay","length","angleCurrent","angleDelta","canvasContext","maxSpeed","Math","PI","upTime","downTime","spinStart","frames","centerX","centerY","rootNode","document","getElementById","onclick","spin","rootNodeRes","wheelInit","setTimeout","window","scrollTo","initCanvas","wheelDraw","canvas","navigator","appVersion","indexOf","createElement","setAttribute","appendChild","getContext","Date","getTime","setInterval","onTimerTick","draw","duration","progress","finished","sin","clearInterval","clear","drawWheel","drawNeedle","drawSegment","key","lastAngle","angle","ctx","value","save","beginPath","moveTo","arc","lineTo","closePath","fillStyle","fill","stroke","translate","rotate","font","fillText","substr","restore","len","PI2","lineWidth","strokeStyle","textBaseline","textAlign","i","fileStyle","change","floor","clearRect","id","children","style","pointerEvents","fileName","_jsxFileName","lineNumber","columnNumber","_c","WheelComponent2","$RefreshReg$"],"sources":["C:/Users/gaspa/OneDrive/Documents/MMI 2/S4/React/SpinningWheel/spin-wheel/src/components/WheelConstructor.jsx"],"sourcesContent":["import React, { useEffect, useState } from \"react\";\r\n\r\nconst WheelComponent = ({\r\n    segments,\r\n    segColors,\r\n    winningSegment,\r\n    onFinished,\r\n    onRotate,\r\n    onRotatefinish,\r\n    primaryColor,\r\n    primaryColoraround,\r\n    contrastColor,\r\n    buttonText,\r\n    isOnlyOnce = true,\r\n    size = 290,\r\n    upDuration = 1000,\r\n    downDuration = 100,\r\n    fontFamily = \"proxima-nova\",\r\n    width = 100,\r\n    height = 100\r\n}) => {\r\n    let currentSegment = \"\";\r\n    let isStarted = false;\r\n    const [isFinished, setFinished] = useState(false);\r\n    let timerHandle = 0;\r\n    const timerDelay = segments.length;\r\n    let angleCurrent = 0;\r\n    let angleDelta = 0;\r\n    let canvasContext = null;\r\n    let maxSpeed = Math.PI / `${segments.length}`;\r\n    const upTime = segments.length * upDuration;\r\n    const downTime = segments.length * downDuration;\r\n    let spinStart = 0;\r\n    let frames = 0;\r\n    const centerX = 300;\r\n    const centerY = 300;\r\n    \r\n    useEffect(() => {\r\n        const rootNode = document.getElementById(\"RootNode\");\r\n        if (rootNode) {\r\n            rootNode.onclick = function () { spin() }\r\n        }\r\n\r\n        const rootNodeRes = document.getElementById(\"RootNodeRes\");\r\n        if (rootNodeRes) {\r\n            rootNodeRes.onclick = function () { spin() }\r\n        }\r\n\r\n        wheelInit();\r\n        setTimeout(() => {\r\n            window.scrollTo(0, 1);\r\n        }, 0);\r\n    }, []);\r\n\r\n\r\n    const wheelInit = () => {\r\n        initCanvas();\r\n        wheelDraw();\r\n\r\n    };\r\n\r\n    const initCanvas = () => {\r\n        let canvas = document.getElementById(\"canvas\");\r\n        if (navigator.appVersion.indexOf(\"MSIE\") !== -1) {\r\n            canvas = document.createElement(\"canvas\");\r\n            canvas.setAttribute(\"width\", width);\r\n            canvas.setAttribute(\"height\", height);\r\n            canvas.setAttribute(\"id\", \"canvas\");\r\n            document.getElementById(\"wheel\").appendChild(canvas);\r\n        }\r\n        // canvas.addEventListener(\"click\", spin, false);\r\n        canvasContext = canvas.getContext(\"2d\");\r\n    };\r\n\r\n    const spin = () => {\r\n        isStarted = true;\r\n        if (timerHandle === 0) {\r\n            spinStart = new Date().getTime();\r\n            maxSpeed = Math.PI / segments.length;\r\n            frames = 0;\r\n            timerHandle = setInterval(onTimerTick, timerDelay);\r\n        }\r\n    };\r\n    const onTimerTick = () => {\r\n        frames++;\r\n        draw();\r\n        const duration = new Date().getTime() - spinStart;\r\n        let progress = 0;\r\n        let finished = false;\r\n        if (duration < upTime) {\r\n            progress = duration / upTime;\r\n            angleDelta = maxSpeed * Math.sin((progress * Math.PI) / 2);\r\n\r\n        } else {\r\n            if (winningSegment) {\r\n                if (currentSegment === winningSegment && frames > segments.length) {\r\n                    progress = duration / upTime;\r\n                    angleDelta =\r\n                        maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2);\r\n                    progress = 1;\r\n                } else {\r\n                    progress = duration / downTime;\r\n                    angleDelta =\r\n                        maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2);\r\n                }\r\n            } else {\r\n                progress = duration / downTime;\r\n                if (progress >= 0.8) {\r\n                    angleDelta =\r\n                        maxSpeed / 1.2 * Math.sin((progress * Math.PI) / 2 + Math.PI / 2);\r\n                } else if (progress >= 0.98) {\r\n                    angleDelta =\r\n                        maxSpeed / 2 * Math.sin((progress * Math.PI) / 2 + Math.PI / 2);\r\n                } else\r\n                    angleDelta =\r\n                        maxSpeed * Math.sin((progress * Math.PI) / 2 + Math.PI / 2);\r\n            }\r\n            if (progress >= 1) finished = true;\r\n        }\r\n\r\n        angleCurrent += angleDelta;\r\n        while (angleCurrent >= Math.PI * 2) angleCurrent -= Math.PI * 2;\r\n        if (finished) {\r\n            setFinished(true);\r\n            onFinished(currentSegment);\r\n            clearInterval(timerHandle);\r\n            timerHandle = 0;\r\n            angleDelta = 0;\r\n        }\r\n    };\r\n\r\n    const wheelDraw = () => {\r\n        clear();\r\n        drawWheel();\r\n        drawNeedle();\r\n    };\r\n\r\n    const draw = () => {\r\n        clear();\r\n        drawWheel();\r\n        drawNeedle();\r\n    };\r\n\r\n    const drawSegment = (key, lastAngle, angle) => {\r\n        const ctx = canvasContext;\r\n        const value = segments[key];\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.moveTo(centerX, centerY);\r\n        ctx.arc(centerX, centerY, size, lastAngle, angle, false);\r\n        ctx.lineTo(centerX, centerY);\r\n        ctx.closePath();\r\n        ctx.fillStyle = segColors[key];\r\n        ctx.fill();\r\n        ctx.stroke();\r\n        ctx.save();\r\n        ctx.translate(centerX, centerY);\r\n        ctx.rotate((lastAngle + angle) / 2);\r\n        ctx.fillStyle = contrastColor || \"white\";\r\n        ctx.font = \"bold 1em \" + fontFamily;\r\n        ctx.fillText(value.substr(0, 21), size / 2 + 20, 0);\r\n        ctx.restore();\r\n    };\r\n\r\n    const drawWheel = () => {\r\n        const ctx = canvasContext;\r\n        let lastAngle = angleCurrent;\r\n        const len = segments.length;\r\n        const PI2 = Math.PI * 2;\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeStyle = primaryColor || \"black\";\r\n        ctx.textBaseline = \"middle\";\r\n        ctx.textAlign = \"center\";\r\n        ctx.font = \"1em \" + fontFamily;\r\n        for (let i = 1; i <= len; i++) {\r\n            const angle = PI2 * (i / len) + angleCurrent;\r\n            drawSegment(i - 1, lastAngle, angle);\r\n            lastAngle = angle;\r\n        }\r\n\r\n        // Draw a center circle\r\n        ctx.beginPath();\r\n        ctx.arc(centerX, centerY, 40, 0, PI2, false);\r\n        ctx.closePath();\r\n        ctx.fillStyle = primaryColor || \"black\";\r\n        ctx.lineWidth = 5;\r\n        ctx.strokeStyle = contrastColor || \"white\";\r\n        ctx.fill();\r\n        ctx.font = \"bold 2em \" + fontFamily;\r\n        ctx.fillStyle = contrastColor || \"white\";\r\n        ctx.textAlign = \"center\";\r\n        ctx.fillText(buttonText || \"Spin\", centerX, centerY + 3);\r\n        ctx.stroke();\r\n\r\n        // Draw outer circle\r\n        ctx.beginPath();\r\n        ctx.arc(centerX, centerY, size, 0, PI2, false);\r\n        ctx.closePath();\r\n        ctx.lineWidth = 25;\r\n        ctx.strokeStyle = primaryColoraround || \"white\";\r\n        ctx.stroke();\r\n    };\r\n\r\n    const drawNeedle = () => {\r\n        const ctx = canvasContext;\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeStyle = contrastColor || \"white\";\r\n        ctx.fileStyle = contrastColor || \"white\";\r\n        ctx.beginPath();\r\n        ctx.moveTo(centerX + 10, centerY - 40);\r\n        ctx.lineTo(centerX - 10, centerY - 40);\r\n        ctx.lineTo(centerX, centerY - 60);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n        const change = angleCurrent + Math.PI / 2;\r\n        let i =\r\n            segments.length -\r\n            Math.floor((change / (Math.PI * 2)) * segments.length) -\r\n            1;\r\n        if (i < 0) i = i + segments.length;\r\n        ctx.textAlign = \"center\";\r\n        ctx.textBaseline = \"middle\";\r\n        ctx.fillStyle = \"transparent\";\r\n        ctx.font = \"bold 1.5em \" + fontFamily;\r\n        currentSegment = segments[i];\r\n        isStarted &&\r\n            ctx.fillText(currentSegment, centerX + 10, centerY + size + 50);\r\n\r\n    };\r\n    const clear = () => {\r\n        const ctx = canvasContext;\r\n        ctx.clearRect(0, 0, 1000, 800);\r\n    };\r\n    return (\r\n        <div id=\"wheel\">\r\n            <canvas\r\n                id=\"canvas\"\r\n                width=\"600\"\r\n                height=\"600\"\r\n                style={{\r\n                    pointerEvents: isFinished && isOnlyOnce ? \"none\" : \"auto\"\r\n                }}\r\n            />\r\n        </div>\r\n    );\r\n};\r\nexport default WheelComponent2;\r\n"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEnD,MAAMC,cAAc,GAAGA,CAAC;EACpBC,QAAQ;EACRC,SAAS;EACTC,cAAc;EACdC,UAAU;EACVC,QAAQ;EACRC,cAAc;EACdC,YAAY;EACZC,kBAAkB;EAClBC,aAAa;EACbC,UAAU;EACVC,UAAU,GAAG,IAAI;EACjBC,IAAI,GAAG,GAAG;EACVC,UAAU,GAAG,IAAI;EACjBC,YAAY,GAAG,GAAG;EAClBC,UAAU,GAAG,cAAc;EAC3BC,KAAK,GAAG,GAAG;EACXC,MAAM,GAAG;AACb,CAAC,KAAK;EAAAC,EAAA;EACF,IAAIC,cAAc,GAAG,EAAE;EACvB,IAAIC,SAAS,GAAG,KAAK;EACrB,MAAM,CAACC,UAAU,EAAEC,WAAW,CAAC,GAAGzB,QAAQ,CAAC,KAAK,CAAC;EACjD,IAAI0B,WAAW,GAAG,CAAC;EACnB,MAAMC,UAAU,GAAGvB,QAAQ,CAACwB,MAAM;EAClC,IAAIC,YAAY,GAAG,CAAC;EACpB,IAAIC,UAAU,GAAG,CAAC;EAClB,IAAIC,aAAa,GAAG,IAAI;EACxB,IAAIC,QAAQ,GAAGC,IAAI,CAACC,EAAE,GAAI,GAAE9B,QAAQ,CAACwB,MAAO,EAAC;EAC7C,MAAMO,MAAM,GAAG/B,QAAQ,CAACwB,MAAM,GAAGZ,UAAU;EAC3C,MAAMoB,QAAQ,GAAGhC,QAAQ,CAACwB,MAAM,GAAGX,YAAY;EAC/C,IAAIoB,SAAS,GAAG,CAAC;EACjB,IAAIC,MAAM,GAAG,CAAC;EACd,MAAMC,OAAO,GAAG,GAAG;EACnB,MAAMC,OAAO,GAAG,GAAG;EAEnBzC,SAAS,CAAC,MAAM;IACZ,MAAM0C,QAAQ,GAAGC,QAAQ,CAACC,cAAc,CAAC,UAAU,CAAC;IACpD,IAAIF,QAAQ,EAAE;MACVA,QAAQ,CAACG,OAAO,GAAG,YAAY;QAAEC,IAAI,CAAC,CAAC;MAAC,CAAC;IAC7C;IAEA,MAAMC,WAAW,GAAGJ,QAAQ,CAACC,cAAc,CAAC,aAAa,CAAC;IAC1D,IAAIG,WAAW,EAAE;MACbA,WAAW,CAACF,OAAO,GAAG,YAAY;QAAEC,IAAI,CAAC,CAAC;MAAC,CAAC;IAChD;IAEAE,SAAS,CAAC,CAAC;IACXC,UAAU,CAAC,MAAM;MACbC,MAAM,CAACC,QAAQ,CAAC,CAAC,EAAE,CAAC,CAAC;IACzB,CAAC,EAAE,CAAC,CAAC;EACT,CAAC,EAAE,EAAE,CAAC;EAGN,MAAMH,SAAS,GAAGA,CAAA,KAAM;IACpBI,UAAU,CAAC,CAAC;IACZC,SAAS,CAAC,CAAC;EAEf,CAAC;EAED,MAAMD,UAAU,GAAGA,CAAA,KAAM;IACrB,IAAIE,MAAM,GAAGX,QAAQ,CAACC,cAAc,CAAC,QAAQ,CAAC;IAC9C,IAAIW,SAAS,CAACC,UAAU,CAACC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE;MAC7CH,MAAM,GAAGX,QAAQ,CAACe,aAAa,CAAC,QAAQ,CAAC;MACzCJ,MAAM,CAACK,YAAY,CAAC,OAAO,EAAEvC,KAAK,CAAC;MACnCkC,MAAM,CAACK,YAAY,CAAC,QAAQ,EAAEtC,MAAM,CAAC;MACrCiC,MAAM,CAACK,YAAY,CAAC,IAAI,EAAE,QAAQ,CAAC;MACnChB,QAAQ,CAACC,cAAc,CAAC,OAAO,CAAC,CAACgB,WAAW,CAACN,MAAM,CAAC;IACxD;IACA;IACAtB,aAAa,GAAGsB,MAAM,CAACO,UAAU,CAAC,IAAI,CAAC;EAC3C,CAAC;EAED,MAAMf,IAAI,GAAGA,CAAA,KAAM;IACftB,SAAS,GAAG,IAAI;IAChB,IAAIG,WAAW,KAAK,CAAC,EAAE;MACnBW,SAAS,GAAG,IAAIwB,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC;MAChC9B,QAAQ,GAAGC,IAAI,CAACC,EAAE,GAAG9B,QAAQ,CAACwB,MAAM;MACpCU,MAAM,GAAG,CAAC;MACVZ,WAAW,GAAGqC,WAAW,CAACC,WAAW,EAAErC,UAAU,CAAC;IACtD;EACJ,CAAC;EACD,MAAMqC,WAAW,GAAGA,CAAA,KAAM;IACtB1B,MAAM,EAAE;IACR2B,IAAI,CAAC,CAAC;IACN,MAAMC,QAAQ,GAAG,IAAIL,IAAI,CAAC,CAAC,CAACC,OAAO,CAAC,CAAC,GAAGzB,SAAS;IACjD,IAAI8B,QAAQ,GAAG,CAAC;IAChB,IAAIC,QAAQ,GAAG,KAAK;IACpB,IAAIF,QAAQ,GAAG/B,MAAM,EAAE;MACnBgC,QAAQ,GAAGD,QAAQ,GAAG/B,MAAM;MAC5BL,UAAU,GAAGE,QAAQ,GAAGC,IAAI,CAACoC,GAAG,CAAEF,QAAQ,GAAGlC,IAAI,CAACC,EAAE,GAAI,CAAC,CAAC;IAE9D,CAAC,MAAM;MACH,IAAI5B,cAAc,EAAE;QAChB,IAAIgB,cAAc,KAAKhB,cAAc,IAAIgC,MAAM,GAAGlC,QAAQ,CAACwB,MAAM,EAAE;UAC/DuC,QAAQ,GAAGD,QAAQ,GAAG/B,MAAM;UAC5BL,UAAU,GACNE,QAAQ,GAAGC,IAAI,CAACoC,GAAG,CAAEF,QAAQ,GAAGlC,IAAI,CAACC,EAAE,GAAI,CAAC,GAAGD,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;UAC/DiC,QAAQ,GAAG,CAAC;QAChB,CAAC,MAAM;UACHA,QAAQ,GAAGD,QAAQ,GAAG9B,QAAQ;UAC9BN,UAAU,GACNE,QAAQ,GAAGC,IAAI,CAACoC,GAAG,CAAEF,QAAQ,GAAGlC,IAAI,CAACC,EAAE,GAAI,CAAC,GAAGD,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;QACnE;MACJ,CAAC,MAAM;QACHiC,QAAQ,GAAGD,QAAQ,GAAG9B,QAAQ;QAC9B,IAAI+B,QAAQ,IAAI,GAAG,EAAE;UACjBrC,UAAU,GACNE,QAAQ,GAAG,GAAG,GAAGC,IAAI,CAACoC,GAAG,CAAEF,QAAQ,GAAGlC,IAAI,CAACC,EAAE,GAAI,CAAC,GAAGD,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;QACzE,CAAC,MAAM,IAAIiC,QAAQ,IAAI,IAAI,EAAE;UACzBrC,UAAU,GACNE,QAAQ,GAAG,CAAC,GAAGC,IAAI,CAACoC,GAAG,CAAEF,QAAQ,GAAGlC,IAAI,CAACC,EAAE,GAAI,CAAC,GAAGD,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;QACvE,CAAC,MACGJ,UAAU,GACNE,QAAQ,GAAGC,IAAI,CAACoC,GAAG,CAAEF,QAAQ,GAAGlC,IAAI,CAACC,EAAE,GAAI,CAAC,GAAGD,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;MACvE;MACA,IAAIiC,QAAQ,IAAI,CAAC,EAAEC,QAAQ,GAAG,IAAI;IACtC;IAEAvC,YAAY,IAAIC,UAAU;IAC1B,OAAOD,YAAY,IAAII,IAAI,CAACC,EAAE,GAAG,CAAC,EAAEL,YAAY,IAAII,IAAI,CAACC,EAAE,GAAG,CAAC;IAC/D,IAAIkC,QAAQ,EAAE;MACV3C,WAAW,CAAC,IAAI,CAAC;MACjBlB,UAAU,CAACe,cAAc,CAAC;MAC1BgD,aAAa,CAAC5C,WAAW,CAAC;MAC1BA,WAAW,GAAG,CAAC;MACfI,UAAU,GAAG,CAAC;IAClB;EACJ,CAAC;EAED,MAAMsB,SAAS,GAAGA,CAAA,KAAM;IACpBmB,KAAK,CAAC,CAAC;IACPC,SAAS,CAAC,CAAC;IACXC,UAAU,CAAC,CAAC;EAChB,CAAC;EAED,MAAMR,IAAI,GAAGA,CAAA,KAAM;IACfM,KAAK,CAAC,CAAC;IACPC,SAAS,CAAC,CAAC;IACXC,UAAU,CAAC,CAAC;EAChB,CAAC;EAED,MAAMC,WAAW,GAAGA,CAACC,GAAG,EAAEC,SAAS,EAAEC,KAAK,KAAK;IAC3C,MAAMC,GAAG,GAAG/C,aAAa;IACzB,MAAMgD,KAAK,GAAG3E,QAAQ,CAACuE,GAAG,CAAC;IAC3BG,GAAG,CAACE,IAAI,CAAC,CAAC;IACVF,GAAG,CAACG,SAAS,CAAC,CAAC;IACfH,GAAG,CAACI,MAAM,CAAC3C,OAAO,EAAEC,OAAO,CAAC;IAC5BsC,GAAG,CAACK,GAAG,CAAC5C,OAAO,EAAEC,OAAO,EAAEzB,IAAI,EAAE6D,SAAS,EAAEC,KAAK,EAAE,KAAK,CAAC;IACxDC,GAAG,CAACM,MAAM,CAAC7C,OAAO,EAAEC,OAAO,CAAC;IAC5BsC,GAAG,CAACO,SAAS,CAAC,CAAC;IACfP,GAAG,CAACQ,SAAS,GAAGjF,SAAS,CAACsE,GAAG,CAAC;IAC9BG,GAAG,CAACS,IAAI,CAAC,CAAC;IACVT,GAAG,CAACU,MAAM,CAAC,CAAC;IACZV,GAAG,CAACE,IAAI,CAAC,CAAC;IACVF,GAAG,CAACW,SAAS,CAAClD,OAAO,EAAEC,OAAO,CAAC;IAC/BsC,GAAG,CAACY,MAAM,CAAC,CAACd,SAAS,GAAGC,KAAK,IAAI,CAAC,CAAC;IACnCC,GAAG,CAACQ,SAAS,GAAG1E,aAAa,IAAI,OAAO;IACxCkE,GAAG,CAACa,IAAI,GAAG,WAAW,GAAGzE,UAAU;IACnC4D,GAAG,CAACc,QAAQ,CAACb,KAAK,CAACc,MAAM,CAAC,CAAC,EAAE,EAAE,CAAC,EAAE9E,IAAI,GAAG,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;IACnD+D,GAAG,CAACgB,OAAO,CAAC,CAAC;EACjB,CAAC;EAED,MAAMtB,SAAS,GAAGA,CAAA,KAAM;IACpB,MAAMM,GAAG,GAAG/C,aAAa;IACzB,IAAI6C,SAAS,GAAG/C,YAAY;IAC5B,MAAMkE,GAAG,GAAG3F,QAAQ,CAACwB,MAAM;IAC3B,MAAMoE,GAAG,GAAG/D,IAAI,CAACC,EAAE,GAAG,CAAC;IACvB4C,GAAG,CAACmB,SAAS,GAAG,CAAC;IACjBnB,GAAG,CAACoB,WAAW,GAAGxF,YAAY,IAAI,OAAO;IACzCoE,GAAG,CAACqB,YAAY,GAAG,QAAQ;IAC3BrB,GAAG,CAACsB,SAAS,GAAG,QAAQ;IACxBtB,GAAG,CAACa,IAAI,GAAG,MAAM,GAAGzE,UAAU;IAC9B,KAAK,IAAImF,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIN,GAAG,EAAEM,CAAC,EAAE,EAAE;MAC3B,MAAMxB,KAAK,GAAGmB,GAAG,IAAIK,CAAC,GAAGN,GAAG,CAAC,GAAGlE,YAAY;MAC5C6C,WAAW,CAAC2B,CAAC,GAAG,CAAC,EAAEzB,SAAS,EAAEC,KAAK,CAAC;MACpCD,SAAS,GAAGC,KAAK;IACrB;;IAEA;IACAC,GAAG,CAACG,SAAS,CAAC,CAAC;IACfH,GAAG,CAACK,GAAG,CAAC5C,OAAO,EAAEC,OAAO,EAAE,EAAE,EAAE,CAAC,EAAEwD,GAAG,EAAE,KAAK,CAAC;IAC5ClB,GAAG,CAACO,SAAS,CAAC,CAAC;IACfP,GAAG,CAACQ,SAAS,GAAG5E,YAAY,IAAI,OAAO;IACvCoE,GAAG,CAACmB,SAAS,GAAG,CAAC;IACjBnB,GAAG,CAACoB,WAAW,GAAGtF,aAAa,IAAI,OAAO;IAC1CkE,GAAG,CAACS,IAAI,CAAC,CAAC;IACVT,GAAG,CAACa,IAAI,GAAG,WAAW,GAAGzE,UAAU;IACnC4D,GAAG,CAACQ,SAAS,GAAG1E,aAAa,IAAI,OAAO;IACxCkE,GAAG,CAACsB,SAAS,GAAG,QAAQ;IACxBtB,GAAG,CAACc,QAAQ,CAAC/E,UAAU,IAAI,MAAM,EAAE0B,OAAO,EAAEC,OAAO,GAAG,CAAC,CAAC;IACxDsC,GAAG,CAACU,MAAM,CAAC,CAAC;;IAEZ;IACAV,GAAG,CAACG,SAAS,CAAC,CAAC;IACfH,GAAG,CAACK,GAAG,CAAC5C,OAAO,EAAEC,OAAO,EAAEzB,IAAI,EAAE,CAAC,EAAEiF,GAAG,EAAE,KAAK,CAAC;IAC9ClB,GAAG,CAACO,SAAS,CAAC,CAAC;IACfP,GAAG,CAACmB,SAAS,GAAG,EAAE;IAClBnB,GAAG,CAACoB,WAAW,GAAGvF,kBAAkB,IAAI,OAAO;IAC/CmE,GAAG,CAACU,MAAM,CAAC,CAAC;EAChB,CAAC;EAED,MAAMf,UAAU,GAAGA,CAAA,KAAM;IACrB,MAAMK,GAAG,GAAG/C,aAAa;IACzB+C,GAAG,CAACmB,SAAS,GAAG,CAAC;IACjBnB,GAAG,CAACoB,WAAW,GAAGtF,aAAa,IAAI,OAAO;IAC1CkE,GAAG,CAACwB,SAAS,GAAG1F,aAAa,IAAI,OAAO;IACxCkE,GAAG,CAACG,SAAS,CAAC,CAAC;IACfH,GAAG,CAACI,MAAM,CAAC3C,OAAO,GAAG,EAAE,EAAEC,OAAO,GAAG,EAAE,CAAC;IACtCsC,GAAG,CAACM,MAAM,CAAC7C,OAAO,GAAG,EAAE,EAAEC,OAAO,GAAG,EAAE,CAAC;IACtCsC,GAAG,CAACM,MAAM,CAAC7C,OAAO,EAAEC,OAAO,GAAG,EAAE,CAAC;IACjCsC,GAAG,CAACO,SAAS,CAAC,CAAC;IACfP,GAAG,CAACS,IAAI,CAAC,CAAC;IACV,MAAMgB,MAAM,GAAG1E,YAAY,GAAGI,IAAI,CAACC,EAAE,GAAG,CAAC;IACzC,IAAImE,CAAC,GACDjG,QAAQ,CAACwB,MAAM,GACfK,IAAI,CAACuE,KAAK,CAAED,MAAM,IAAItE,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC,GAAI9B,QAAQ,CAACwB,MAAM,CAAC,GACtD,CAAC;IACL,IAAIyE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGA,CAAC,GAAGjG,QAAQ,CAACwB,MAAM;IAClCkD,GAAG,CAACsB,SAAS,GAAG,QAAQ;IACxBtB,GAAG,CAACqB,YAAY,GAAG,QAAQ;IAC3BrB,GAAG,CAACQ,SAAS,GAAG,aAAa;IAC7BR,GAAG,CAACa,IAAI,GAAG,aAAa,GAAGzE,UAAU;IACrCI,cAAc,GAAGlB,QAAQ,CAACiG,CAAC,CAAC;IAC5B9E,SAAS,IACLuD,GAAG,CAACc,QAAQ,CAACtE,cAAc,EAAEiB,OAAO,GAAG,EAAE,EAAEC,OAAO,GAAGzB,IAAI,GAAG,EAAE,CAAC;EAEvE,CAAC;EACD,MAAMwD,KAAK,GAAGA,CAAA,KAAM;IAChB,MAAMO,GAAG,GAAG/C,aAAa;IACzB+C,GAAG,CAAC2B,SAAS,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,EAAE,GAAG,CAAC;EAClC,CAAC;EACD,oBACIvG,OAAA;IAAKwG,EAAE,EAAC,OAAO;IAAAC,QAAA,eACXzG,OAAA;MACIwG,EAAE,EAAC,QAAQ;MACXvF,KAAK,EAAC,KAAK;MACXC,MAAM,EAAC,KAAK;MACZwF,KAAK,EAAE;QACHC,aAAa,EAAErF,UAAU,IAAIV,UAAU,GAAG,MAAM,GAAG;MACvD;IAAE;MAAAgG,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACL;EAAC;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACD,CAAC;AAEd,CAAC;AAAC5F,EAAA,CAnPIlB,cAAc;AAAA+G,EAAA,GAAd/G,cAAc;AAoPpB,eAAegH,eAAe;AAAC,IAAAD,EAAA;AAAAE,YAAA,CAAAF,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}