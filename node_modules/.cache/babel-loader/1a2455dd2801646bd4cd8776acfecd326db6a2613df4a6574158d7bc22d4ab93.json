{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.System = void 0;\nconst base_system_1 = require(\"./base-system\");\nconst line_1 = require(\"./bodies/line\");\nconst model_1 = require(\"./model\");\nconst utils_1 = require(\"./utils\");\nconst intersect_1 = require(\"./intersect\");\nconst optimized_1 = require(\"./optimized\");\n/**\n * collision system\n */\nclass System extends base_system_1.BaseSystem {\n  constructor() {\n    super(...arguments);\n    /**\n     * the last collision result\n     */\n    this.response = new model_1.Response();\n  }\n  /**\n   * separate (move away) bodies\n   */\n  separate() {\n    (0, optimized_1.forEach)(this.all(), body => {\n      this.separateBody(body);\n    });\n  }\n  /**\n   * separate (move away) 1 body\n   */\n  separateBody(body) {\n    if (body.isStatic || body.isTrigger) {\n      return;\n    }\n    const offsets = {\n      x: 0,\n      y: 0\n    };\n    const addOffsets = ({\n      overlapV: {\n        x,\n        y\n      }\n    }) => {\n      offsets.x += x;\n      offsets.y += y;\n    };\n    this.checkOne(body, addOffsets);\n    if (offsets.x || offsets.y) {\n      body.setPosition(body.x - offsets.x, body.y - offsets.y);\n    }\n  }\n  /**\n   * check one body collisions with callback\n   */\n  checkOne(body, callback = utils_1.returnTrue, response = this.response) {\n    // no need to check static body collision\n    if (body.isStatic) {\n      return false;\n    }\n    const bodies = this.search(body);\n    const checkCollision = candidate => {\n      if (candidate !== body && this.checkCollision(body, candidate, response)) {\n        return callback(response);\n      }\n    };\n    return (0, optimized_1.some)(bodies, checkCollision);\n  }\n  /**\n   * check all bodies collisions with callback\n   */\n  checkAll(callback = utils_1.returnTrue, response = this.response) {\n    const checkOne = body => {\n      return this.checkOne(body, callback, response);\n    };\n    return (0, optimized_1.some)(this.all(), checkOne);\n  }\n  /**\n   * check do 2 objects collide\n   */\n  checkCollision(bodyA, bodyB, response = this.response) {\n    // assess the bodies real aabb without padding\n    if (!bodyA.bbox || !bodyB.bbox || (0, utils_1.notIntersectAABB)(bodyA.bbox, bodyB.bbox)) {\n      return false;\n    }\n    const sat = (0, utils_1.getSATTest)(bodyA, bodyB);\n    // 99% of cases\n    if (bodyA.isConvex && bodyB.isConvex) {\n      // always first clear response\n      response.clear();\n      return sat(bodyA, bodyB, response);\n    }\n    // more complex (non convex) cases\n    const convexBodiesA = (0, intersect_1.ensureConvex)(bodyA);\n    const convexBodiesB = (0, intersect_1.ensureConvex)(bodyB);\n    let overlapX = 0;\n    let overlapY = 0;\n    let collided = false;\n    (0, optimized_1.forEach)(convexBodiesA, convexBodyA => {\n      (0, optimized_1.forEach)(convexBodiesB, convexBodyB => {\n        // always first clear response\n        response.clear();\n        if (sat(convexBodyA, convexBodyB, response)) {\n          collided = true;\n          overlapX += response.overlapV.x;\n          overlapY += response.overlapV.y;\n        }\n      });\n    });\n    if (collided) {\n      const vector = new model_1.SATVector(overlapX, overlapY);\n      response.a = bodyA;\n      response.b = bodyB;\n      response.overlapV.x = overlapX;\n      response.overlapV.y = overlapY;\n      response.overlapN = vector.normalize();\n      response.overlap = vector.len();\n      response.aInB = (0, utils_1.checkAInB)(bodyA, bodyB);\n      response.bInA = (0, utils_1.checkAInB)(bodyB, bodyA);\n    }\n    return collided;\n  }\n  /**\n   * raycast to get collider of ray from start to end\n   */\n  raycast(start, end, allow = utils_1.returnTrue) {\n    let minDistance = Infinity;\n    let result = null;\n    if (!this.ray) {\n      this.ray = new line_1.Line(start, end, {\n        isTrigger: true\n      });\n    } else {\n      this.ray.start = start;\n      this.ray.end = end;\n    }\n    this.insert(this.ray);\n    this.checkOne(this.ray, ({\n      b: body\n    }) => {\n      if (!allow(body)) {\n        return false;\n      }\n      const points = body.type === model_1.BodyType.Circle ? (0, intersect_1.intersectLineCircle)(this.ray, body) : (0, intersect_1.intersectLinePolygon)(this.ray, body);\n      (0, optimized_1.forEach)(points, point => {\n        const pointDistance = (0, utils_1.distance)(start, point);\n        if (pointDistance < minDistance) {\n          minDistance = pointDistance;\n          result = {\n            point,\n            body\n          };\n        }\n      });\n    });\n    this.remove(this.ray);\n    return result;\n  }\n}\nexports.System = System;","map":{"version":3,"names":["Object","defineProperty","exports","value","System","base_system_1","require","line_1","model_1","utils_1","intersect_1","optimized_1","BaseSystem","constructor","arguments","response","Response","separate","forEach","all","body","separateBody","isStatic","isTrigger","offsets","x","y","addOffsets","overlapV","checkOne","setPosition","callback","returnTrue","bodies","search","checkCollision","candidate","some","checkAll","bodyA","bodyB","bbox","notIntersectAABB","sat","getSATTest","isConvex","clear","convexBodiesA","ensureConvex","convexBodiesB","overlapX","overlapY","collided","convexBodyA","convexBodyB","vector","SATVector","a","b","overlapN","normalize","overlap","len","aInB","checkAInB","bInA","raycast","start","end","allow","minDistance","Infinity","result","ray","Line","insert","points","type","BodyType","Circle","intersectLineCircle","intersectLinePolygon","point","pointDistance","distance","remove"],"sources":["C:/Users/gaspa/OneDrive/Documents/MMI 2/S4/React/SpinningWheel/spin-wheel/node_modules/detect-collisions/dist/system.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.System = void 0;\nconst base_system_1 = require(\"./base-system\");\nconst line_1 = require(\"./bodies/line\");\nconst model_1 = require(\"./model\");\nconst utils_1 = require(\"./utils\");\nconst intersect_1 = require(\"./intersect\");\nconst optimized_1 = require(\"./optimized\");\n/**\n * collision system\n */\nclass System extends base_system_1.BaseSystem {\n    constructor() {\n        super(...arguments);\n        /**\n         * the last collision result\n         */\n        this.response = new model_1.Response();\n    }\n    /**\n     * separate (move away) bodies\n     */\n    separate() {\n        (0, optimized_1.forEach)(this.all(), (body) => {\n            this.separateBody(body);\n        });\n    }\n    /**\n     * separate (move away) 1 body\n     */\n    separateBody(body) {\n        if (body.isStatic || body.isTrigger) {\n            return;\n        }\n        const offsets = { x: 0, y: 0 };\n        const addOffsets = ({ overlapV: { x, y } }) => {\n            offsets.x += x;\n            offsets.y += y;\n        };\n        this.checkOne(body, addOffsets);\n        if (offsets.x || offsets.y) {\n            body.setPosition(body.x - offsets.x, body.y - offsets.y);\n        }\n    }\n    /**\n     * check one body collisions with callback\n     */\n    checkOne(body, callback = utils_1.returnTrue, response = this.response) {\n        // no need to check static body collision\n        if (body.isStatic) {\n            return false;\n        }\n        const bodies = this.search(body);\n        const checkCollision = (candidate) => {\n            if (candidate !== body &&\n                this.checkCollision(body, candidate, response)) {\n                return callback(response);\n            }\n        };\n        return (0, optimized_1.some)(bodies, checkCollision);\n    }\n    /**\n     * check all bodies collisions with callback\n     */\n    checkAll(callback = utils_1.returnTrue, response = this.response) {\n        const checkOne = (body) => {\n            return this.checkOne(body, callback, response);\n        };\n        return (0, optimized_1.some)(this.all(), checkOne);\n    }\n    /**\n     * check do 2 objects collide\n     */\n    checkCollision(bodyA, bodyB, response = this.response) {\n        // assess the bodies real aabb without padding\n        if (!bodyA.bbox ||\n            !bodyB.bbox ||\n            (0, utils_1.notIntersectAABB)(bodyA.bbox, bodyB.bbox)) {\n            return false;\n        }\n        const sat = (0, utils_1.getSATTest)(bodyA, bodyB);\n        // 99% of cases\n        if (bodyA.isConvex && bodyB.isConvex) {\n            // always first clear response\n            response.clear();\n            return sat(bodyA, bodyB, response);\n        }\n        // more complex (non convex) cases\n        const convexBodiesA = (0, intersect_1.ensureConvex)(bodyA);\n        const convexBodiesB = (0, intersect_1.ensureConvex)(bodyB);\n        let overlapX = 0;\n        let overlapY = 0;\n        let collided = false;\n        (0, optimized_1.forEach)(convexBodiesA, (convexBodyA) => {\n            (0, optimized_1.forEach)(convexBodiesB, (convexBodyB) => {\n                // always first clear response\n                response.clear();\n                if (sat(convexBodyA, convexBodyB, response)) {\n                    collided = true;\n                    overlapX += response.overlapV.x;\n                    overlapY += response.overlapV.y;\n                }\n            });\n        });\n        if (collided) {\n            const vector = new model_1.SATVector(overlapX, overlapY);\n            response.a = bodyA;\n            response.b = bodyB;\n            response.overlapV.x = overlapX;\n            response.overlapV.y = overlapY;\n            response.overlapN = vector.normalize();\n            response.overlap = vector.len();\n            response.aInB = (0, utils_1.checkAInB)(bodyA, bodyB);\n            response.bInA = (0, utils_1.checkAInB)(bodyB, bodyA);\n        }\n        return collided;\n    }\n    /**\n     * raycast to get collider of ray from start to end\n     */\n    raycast(start, end, allow = utils_1.returnTrue) {\n        let minDistance = Infinity;\n        let result = null;\n        if (!this.ray) {\n            this.ray = new line_1.Line(start, end, { isTrigger: true });\n        }\n        else {\n            this.ray.start = start;\n            this.ray.end = end;\n        }\n        this.insert(this.ray);\n        this.checkOne(this.ray, ({ b: body }) => {\n            if (!allow(body)) {\n                return false;\n            }\n            const points = body.type === model_1.BodyType.Circle\n                ? (0, intersect_1.intersectLineCircle)(this.ray, body)\n                : (0, intersect_1.intersectLinePolygon)(this.ray, body);\n            (0, optimized_1.forEach)(points, (point) => {\n                const pointDistance = (0, utils_1.distance)(start, point);\n                if (pointDistance < minDistance) {\n                    minDistance = pointDistance;\n                    result = { point, body };\n                }\n            });\n        });\n        this.remove(this.ray);\n        return result;\n    }\n}\nexports.System = System;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}