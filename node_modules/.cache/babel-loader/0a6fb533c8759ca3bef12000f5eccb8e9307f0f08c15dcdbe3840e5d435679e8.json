{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.returnTrue = exports.cloneResponse = exports.drawBVH = exports.drawPolygon = exports.dashLineTo = exports.getSATTest = exports.getBounceDirection = exports.mapArrayToVector = exports.mapVectorToArray = exports.clonePointsArray = exports.checkAInB = exports.intersectAABB = exports.notIntersectAABB = exports.bodyMoved = exports.extendBody = exports.clockwise = exports.distance = exports.ensurePolygonPoints = exports.ensureVectorPoint = exports.createBox = exports.createEllipse = exports.rad2deg = exports.deg2rad = exports.RAD2DEG = exports.DEG2RAD = void 0;\nconst sat_1 = require(\"sat\");\nconst intersect_1 = require(\"./intersect\");\nconst model_1 = require(\"./model\");\nconst optimized_1 = require(\"./optimized\");\n/* helpers for faster getSATTest() and checkAInB() */\nconst testMap = {\n  satCircleCircle: sat_1.testCircleCircle,\n  satCirclePolygon: sat_1.testCirclePolygon,\n  satPolygonCircle: sat_1.testPolygonCircle,\n  satPolygonPolygon: sat_1.testPolygonPolygon,\n  inCircleCircle: intersect_1.circleInCircle,\n  inCirclePolygon: intersect_1.circleInPolygon,\n  inPolygonCircle: intersect_1.polygonInCircle,\n  inPolygonPolygon: intersect_1.polygonInPolygon\n};\nfunction createMap(bodyType, testType) {\n  return Object.values(model_1.BodyType).reduce((result, type) => Object.assign(Object.assign({}, result), {\n    [type]: type === model_1.BodyType.Circle ? testMap[`${testType}${bodyType}Circle`] : testMap[`${testType}${bodyType}Polygon`]\n  }), {});\n}\nconst circleSATFunctions = createMap(model_1.BodyType.Circle, \"sat\");\nconst circleInFunctions = createMap(model_1.BodyType.Circle, \"in\");\nconst polygonSATFunctions = createMap(model_1.BodyType.Polygon, \"sat\");\nconst polygonInFunctions = createMap(model_1.BodyType.Polygon, \"in\");\nexports.DEG2RAD = Math.PI / 180;\nexports.RAD2DEG = 180 / Math.PI;\n/**\n * convert from degrees to radians\n */\nfunction deg2rad(degrees) {\n  return degrees * exports.DEG2RAD;\n}\nexports.deg2rad = deg2rad;\n/**\n * convert from radians to degrees\n */\nfunction rad2deg(radians) {\n  return radians * exports.RAD2DEG;\n}\nexports.rad2deg = rad2deg;\n/**\n * creates ellipse-shaped polygon based on params\n */\nfunction createEllipse(radiusX, radiusY = radiusX, step = 1) {\n  const steps = Math.PI * Math.hypot(radiusX, radiusY) * 2;\n  const length = Math.max(8, Math.ceil(steps / Math.max(1, step)));\n  const ellipse = [];\n  for (let index = 0; index < length; index++) {\n    const value = index / length * 2 * Math.PI;\n    const x = Math.cos(value) * radiusX;\n    const y = Math.sin(value) * radiusY;\n    ellipse.push(new sat_1.Vector(x, y));\n  }\n  return ellipse;\n}\nexports.createEllipse = createEllipse;\n/**\n * creates box shaped polygon points\n */\nfunction createBox(width, height) {\n  return [new sat_1.Vector(0, 0), new sat_1.Vector(width, 0), new sat_1.Vector(width, height), new sat_1.Vector(0, height)];\n}\nexports.createBox = createBox;\n/**\n * ensure SATVector type point result\n */\nfunction ensureVectorPoint(point = {}) {\n  return point instanceof sat_1.Vector ? point : new sat_1.Vector(point.x || 0, point.y || 0);\n}\nexports.ensureVectorPoint = ensureVectorPoint;\n/**\n * ensure Vector points (for polygon) in counter-clockwise order\n */\nfunction ensurePolygonPoints(points = []) {\n  const polygonPoints = (0, optimized_1.map)(points, ensureVectorPoint);\n  return clockwise(polygonPoints) ? polygonPoints.reverse() : polygonPoints;\n}\nexports.ensurePolygonPoints = ensurePolygonPoints;\n/**\n * get distance between two Vector points\n */\nfunction distance(bodyA, bodyB) {\n  const xDiff = bodyA.x - bodyB.x;\n  const yDiff = bodyA.y - bodyB.y;\n  return Math.hypot(xDiff, yDiff);\n}\nexports.distance = distance;\n/**\n * check [is clockwise] direction of polygon\n */\nfunction clockwise(points) {\n  const length = points.length;\n  let sum = 0;\n  (0, optimized_1.forEach)(points, (v1, index) => {\n    const v2 = points[(index + 1) % length];\n    sum += (v2.x - v1.x) * (v2.y + v1.y);\n  });\n  return sum > 0;\n}\nexports.clockwise = clockwise;\n/**\n * used for all types of bodies in constructor\n */\nfunction extendBody(body, options) {\n  body.isStatic = !!(options === null || options === void 0 ? void 0 : options.isStatic);\n  body.isTrigger = !!(options === null || options === void 0 ? void 0 : options.isTrigger);\n  body.padding = (options === null || options === void 0 ? void 0 : options.padding) || 0;\n  if (body.type !== model_1.BodyType.Circle) {\n    body.isCentered = (options === null || options === void 0 ? void 0 : options.isCentered) || false;\n  }\n  body.setAngle((options === null || options === void 0 ? void 0 : options.angle) || 0);\n}\nexports.extendBody = extendBody;\n/**\n * check if body moved outside of its padding\n */\nfunction bodyMoved(body) {\n  const {\n    bbox,\n    minX,\n    minY,\n    maxX,\n    maxY\n  } = body;\n  return bbox.minX < minX || bbox.minY < minY || bbox.maxX > maxX || bbox.maxY > maxY;\n}\nexports.bodyMoved = bodyMoved;\n/**\n * returns true if two boxes not intersect\n */\nfunction notIntersectAABB(bodyA, bodyB) {\n  return bodyB.minX > bodyA.maxX || bodyB.minY > bodyA.maxY || bodyB.maxX < bodyA.minX || bodyB.maxY < bodyA.minY;\n}\nexports.notIntersectAABB = notIntersectAABB;\n/**\n * checks if two boxes intersect\n */\nfunction intersectAABB(bodyA, bodyB) {\n  return !notIntersectAABB(bodyA, bodyB);\n}\nexports.intersectAABB = intersectAABB;\n/**\n * checks if body a is in body b\n */\nfunction checkAInB(bodyA, bodyB) {\n  const check = bodyA.type === model_1.BodyType.Circle ? circleInFunctions : polygonInFunctions;\n  return check[bodyB.type](bodyA, bodyB);\n}\nexports.checkAInB = checkAInB;\n/**\n * clone sat vector points array into vector points array\n */\nfunction clonePointsArray(points) {\n  return (0, optimized_1.map)(points, ({\n    x,\n    y\n  }) => ({\n    x,\n    y\n  }));\n}\nexports.clonePointsArray = clonePointsArray;\n/**\n * change format from SAT.js to poly-decomp\n */\nfunction mapVectorToArray({\n  x,\n  y\n} = {\n  x: 0,\n  y: 0\n}) {\n  return [x, y];\n}\nexports.mapVectorToArray = mapVectorToArray;\n/**\n * change format from poly-decomp to SAT.js\n */\nfunction mapArrayToVector([x, y] = [0, 0]) {\n  return {\n    x,\n    y\n  };\n}\nexports.mapArrayToVector = mapArrayToVector;\n/**\n * given 2 bodies calculate vector of bounce assuming equal mass and they are circles\n */\nfunction getBounceDirection(body, collider) {\n  const v2 = new sat_1.Vector(collider.x - body.x, collider.y - body.y);\n  const v1 = new sat_1.Vector(body.x - collider.x, body.y - collider.y);\n  const len = v1.dot(v2.normalize()) * 2;\n  return new sat_1.Vector(v2.x * len - v1.x, v2.y * len - v1.y).normalize();\n}\nexports.getBounceDirection = getBounceDirection;\n/**\n * returns correct sat.js testing function based on body types\n */\nfunction getSATTest(bodyA, bodyB) {\n  const check = bodyA.type === model_1.BodyType.Circle ? circleSATFunctions : polygonSATFunctions;\n  return check[bodyB.type];\n}\nexports.getSATTest = getSATTest;\n/**\n * draws dashed line on canvas context\n */\nfunction dashLineTo(context, fromX, fromY, toX, toY, dash = 2, gap = 4) {\n  const xDiff = toX - fromX;\n  const yDiff = toY - fromY;\n  const arc = Math.atan2(yDiff, xDiff);\n  const offsetX = Math.cos(arc);\n  const offsetY = Math.sin(arc);\n  let posX = fromX;\n  let posY = fromY;\n  let dist = Math.hypot(xDiff, yDiff);\n  while (dist > 0) {\n    const step = Math.min(dist, dash);\n    context.moveTo(posX, posY);\n    context.lineTo(posX + offsetX * step, posY + offsetY * step);\n    posX += offsetX * (dash + gap);\n    posY += offsetY * (dash + gap);\n    dist -= dash + gap;\n  }\n}\nexports.dashLineTo = dashLineTo;\n/**\n * draw polygon\n */\nfunction drawPolygon(context, {\n  pos,\n  calcPoints\n}, isTrigger = false) {\n  const lastPoint = calcPoints[calcPoints.length - 1];\n  const fromX = pos.x + lastPoint.x;\n  const fromY = pos.y + lastPoint.y;\n  if (calcPoints.length === 1) {\n    context.arc(fromX, fromY, 1, 0, Math.PI * 2);\n  } else {\n    context.moveTo(fromX, fromY);\n  }\n  (0, optimized_1.forEach)(calcPoints, (point, index) => {\n    const toX = pos.x + point.x;\n    const toY = pos.y + point.y;\n    if (isTrigger) {\n      const prev = calcPoints[index - 1] || lastPoint;\n      dashLineTo(context, pos.x + prev.x, pos.y + prev.y, toX, toY);\n    } else {\n      context.lineTo(toX, toY);\n    }\n  });\n}\nexports.drawPolygon = drawPolygon;\n/**\n * draw body bounding body box\n */\nfunction drawBVH(context, body) {\n  drawPolygon(context, {\n    pos: {\n      x: body.minX,\n      y: body.minY\n    },\n    calcPoints: createBox(body.maxX - body.minX, body.maxY - body.minY)\n  });\n}\nexports.drawBVH = drawBVH;\n/**\n * clone response object returning new response with previous ones values\n */\nfunction cloneResponse(response) {\n  const clone = new sat_1.Response();\n  const {\n    a,\n    b,\n    overlap,\n    overlapN,\n    overlapV,\n    aInB,\n    bInA\n  } = response;\n  clone.a = a;\n  clone.b = b;\n  clone.overlap = overlap;\n  clone.overlapN = overlapN.clone();\n  clone.overlapV = overlapV.clone();\n  clone.aInB = aInB;\n  clone.bInA = bInA;\n  return clone;\n}\nexports.cloneResponse = cloneResponse;\n/**\n * dummy fn used as default, for optimization\n */\nfunction returnTrue() {\n  return true;\n}\nexports.returnTrue = returnTrue;","map":{"version":3,"names":["Object","defineProperty","exports","value","returnTrue","cloneResponse","drawBVH","drawPolygon","dashLineTo","getSATTest","getBounceDirection","mapArrayToVector","mapVectorToArray","clonePointsArray","checkAInB","intersectAABB","notIntersectAABB","bodyMoved","extendBody","clockwise","distance","ensurePolygonPoints","ensureVectorPoint","createBox","createEllipse","rad2deg","deg2rad","RAD2DEG","DEG2RAD","sat_1","require","intersect_1","model_1","optimized_1","testMap","satCircleCircle","testCircleCircle","satCirclePolygon","testCirclePolygon","satPolygonCircle","testPolygonCircle","satPolygonPolygon","testPolygonPolygon","inCircleCircle","circleInCircle","inCirclePolygon","circleInPolygon","inPolygonCircle","polygonInCircle","inPolygonPolygon","polygonInPolygon","createMap","bodyType","testType","values","BodyType","reduce","result","type","assign","Circle","circleSATFunctions","circleInFunctions","polygonSATFunctions","Polygon","polygonInFunctions","Math","PI","degrees","radians","radiusX","radiusY","step","steps","hypot","length","max","ceil","ellipse","index","x","cos","y","sin","push","Vector","width","height","point","points","polygonPoints","map","reverse","bodyA","bodyB","xDiff","yDiff","sum","forEach","v1","v2","body","options","isStatic","isTrigger","padding","isCentered","setAngle","angle","bbox","minX","minY","maxX","maxY","check","collider","len","dot","normalize","context","fromX","fromY","toX","toY","dash","gap","arc","atan2","offsetX","offsetY","posX","posY","dist","min","moveTo","lineTo","pos","calcPoints","lastPoint","prev","response","clone","Response","a","b","overlap","overlapN","overlapV","aInB","bInA"],"sources":["C:/Users/gaspa/OneDrive/Documents/MMI 2/S4/React/SpinningWheel/spin-wheel/node_modules/detect-collisions/dist/utils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.returnTrue = exports.cloneResponse = exports.drawBVH = exports.drawPolygon = exports.dashLineTo = exports.getSATTest = exports.getBounceDirection = exports.mapArrayToVector = exports.mapVectorToArray = exports.clonePointsArray = exports.checkAInB = exports.intersectAABB = exports.notIntersectAABB = exports.bodyMoved = exports.extendBody = exports.clockwise = exports.distance = exports.ensurePolygonPoints = exports.ensureVectorPoint = exports.createBox = exports.createEllipse = exports.rad2deg = exports.deg2rad = exports.RAD2DEG = exports.DEG2RAD = void 0;\nconst sat_1 = require(\"sat\");\nconst intersect_1 = require(\"./intersect\");\nconst model_1 = require(\"./model\");\nconst optimized_1 = require(\"./optimized\");\n/* helpers for faster getSATTest() and checkAInB() */\nconst testMap = {\n    satCircleCircle: sat_1.testCircleCircle,\n    satCirclePolygon: sat_1.testCirclePolygon,\n    satPolygonCircle: sat_1.testPolygonCircle,\n    satPolygonPolygon: sat_1.testPolygonPolygon,\n    inCircleCircle: intersect_1.circleInCircle,\n    inCirclePolygon: intersect_1.circleInPolygon,\n    inPolygonCircle: intersect_1.polygonInCircle,\n    inPolygonPolygon: intersect_1.polygonInPolygon,\n};\nfunction createMap(bodyType, testType) {\n    return Object.values(model_1.BodyType).reduce((result, type) => (Object.assign(Object.assign({}, result), { [type]: type === model_1.BodyType.Circle\n            ? testMap[`${testType}${bodyType}Circle`]\n            : testMap[`${testType}${bodyType}Polygon`] })), {});\n}\nconst circleSATFunctions = createMap(model_1.BodyType.Circle, \"sat\");\nconst circleInFunctions = createMap(model_1.BodyType.Circle, \"in\");\nconst polygonSATFunctions = createMap(model_1.BodyType.Polygon, \"sat\");\nconst polygonInFunctions = createMap(model_1.BodyType.Polygon, \"in\");\nexports.DEG2RAD = Math.PI / 180;\nexports.RAD2DEG = 180 / Math.PI;\n/**\n * convert from degrees to radians\n */\nfunction deg2rad(degrees) {\n    return degrees * exports.DEG2RAD;\n}\nexports.deg2rad = deg2rad;\n/**\n * convert from radians to degrees\n */\nfunction rad2deg(radians) {\n    return radians * exports.RAD2DEG;\n}\nexports.rad2deg = rad2deg;\n/**\n * creates ellipse-shaped polygon based on params\n */\nfunction createEllipse(radiusX, radiusY = radiusX, step = 1) {\n    const steps = Math.PI * Math.hypot(radiusX, radiusY) * 2;\n    const length = Math.max(8, Math.ceil(steps / Math.max(1, step)));\n    const ellipse = [];\n    for (let index = 0; index < length; index++) {\n        const value = (index / length) * 2 * Math.PI;\n        const x = Math.cos(value) * radiusX;\n        const y = Math.sin(value) * radiusY;\n        ellipse.push(new sat_1.Vector(x, y));\n    }\n    return ellipse;\n}\nexports.createEllipse = createEllipse;\n/**\n * creates box shaped polygon points\n */\nfunction createBox(width, height) {\n    return [\n        new sat_1.Vector(0, 0),\n        new sat_1.Vector(width, 0),\n        new sat_1.Vector(width, height),\n        new sat_1.Vector(0, height),\n    ];\n}\nexports.createBox = createBox;\n/**\n * ensure SATVector type point result\n */\nfunction ensureVectorPoint(point = {}) {\n    return point instanceof sat_1.Vector\n        ? point\n        : new sat_1.Vector(point.x || 0, point.y || 0);\n}\nexports.ensureVectorPoint = ensureVectorPoint;\n/**\n * ensure Vector points (for polygon) in counter-clockwise order\n */\nfunction ensurePolygonPoints(points = []) {\n    const polygonPoints = (0, optimized_1.map)(points, ensureVectorPoint);\n    return clockwise(polygonPoints) ? polygonPoints.reverse() : polygonPoints;\n}\nexports.ensurePolygonPoints = ensurePolygonPoints;\n/**\n * get distance between two Vector points\n */\nfunction distance(bodyA, bodyB) {\n    const xDiff = bodyA.x - bodyB.x;\n    const yDiff = bodyA.y - bodyB.y;\n    return Math.hypot(xDiff, yDiff);\n}\nexports.distance = distance;\n/**\n * check [is clockwise] direction of polygon\n */\nfunction clockwise(points) {\n    const length = points.length;\n    let sum = 0;\n    (0, optimized_1.forEach)(points, (v1, index) => {\n        const v2 = points[(index + 1) % length];\n        sum += (v2.x - v1.x) * (v2.y + v1.y);\n    });\n    return sum > 0;\n}\nexports.clockwise = clockwise;\n/**\n * used for all types of bodies in constructor\n */\nfunction extendBody(body, options) {\n    body.isStatic = !!(options === null || options === void 0 ? void 0 : options.isStatic);\n    body.isTrigger = !!(options === null || options === void 0 ? void 0 : options.isTrigger);\n    body.padding = (options === null || options === void 0 ? void 0 : options.padding) || 0;\n    if (body.type !== model_1.BodyType.Circle) {\n        body.isCentered = (options === null || options === void 0 ? void 0 : options.isCentered) || false;\n    }\n    body.setAngle((options === null || options === void 0 ? void 0 : options.angle) || 0);\n}\nexports.extendBody = extendBody;\n/**\n * check if body moved outside of its padding\n */\nfunction bodyMoved(body) {\n    const { bbox, minX, minY, maxX, maxY } = body;\n    return (bbox.minX < minX || bbox.minY < minY || bbox.maxX > maxX || bbox.maxY > maxY);\n}\nexports.bodyMoved = bodyMoved;\n/**\n * returns true if two boxes not intersect\n */\nfunction notIntersectAABB(bodyA, bodyB) {\n    return (bodyB.minX > bodyA.maxX ||\n        bodyB.minY > bodyA.maxY ||\n        bodyB.maxX < bodyA.minX ||\n        bodyB.maxY < bodyA.minY);\n}\nexports.notIntersectAABB = notIntersectAABB;\n/**\n * checks if two boxes intersect\n */\nfunction intersectAABB(bodyA, bodyB) {\n    return !notIntersectAABB(bodyA, bodyB);\n}\nexports.intersectAABB = intersectAABB;\n/**\n * checks if body a is in body b\n */\nfunction checkAInB(bodyA, bodyB) {\n    const check = bodyA.type === model_1.BodyType.Circle ? circleInFunctions : polygonInFunctions;\n    return check[bodyB.type](bodyA, bodyB);\n}\nexports.checkAInB = checkAInB;\n/**\n * clone sat vector points array into vector points array\n */\nfunction clonePointsArray(points) {\n    return (0, optimized_1.map)(points, ({ x, y }) => ({ x, y }));\n}\nexports.clonePointsArray = clonePointsArray;\n/**\n * change format from SAT.js to poly-decomp\n */\nfunction mapVectorToArray({ x, y } = { x: 0, y: 0 }) {\n    return [x, y];\n}\nexports.mapVectorToArray = mapVectorToArray;\n/**\n * change format from poly-decomp to SAT.js\n */\nfunction mapArrayToVector([x, y] = [0, 0]) {\n    return { x, y };\n}\nexports.mapArrayToVector = mapArrayToVector;\n/**\n * given 2 bodies calculate vector of bounce assuming equal mass and they are circles\n */\nfunction getBounceDirection(body, collider) {\n    const v2 = new sat_1.Vector(collider.x - body.x, collider.y - body.y);\n    const v1 = new sat_1.Vector(body.x - collider.x, body.y - collider.y);\n    const len = v1.dot(v2.normalize()) * 2;\n    return new sat_1.Vector(v2.x * len - v1.x, v2.y * len - v1.y).normalize();\n}\nexports.getBounceDirection = getBounceDirection;\n/**\n * returns correct sat.js testing function based on body types\n */\nfunction getSATTest(bodyA, bodyB) {\n    const check = bodyA.type === model_1.BodyType.Circle ? circleSATFunctions : polygonSATFunctions;\n    return check[bodyB.type];\n}\nexports.getSATTest = getSATTest;\n/**\n * draws dashed line on canvas context\n */\nfunction dashLineTo(context, fromX, fromY, toX, toY, dash = 2, gap = 4) {\n    const xDiff = toX - fromX;\n    const yDiff = toY - fromY;\n    const arc = Math.atan2(yDiff, xDiff);\n    const offsetX = Math.cos(arc);\n    const offsetY = Math.sin(arc);\n    let posX = fromX;\n    let posY = fromY;\n    let dist = Math.hypot(xDiff, yDiff);\n    while (dist > 0) {\n        const step = Math.min(dist, dash);\n        context.moveTo(posX, posY);\n        context.lineTo(posX + offsetX * step, posY + offsetY * step);\n        posX += offsetX * (dash + gap);\n        posY += offsetY * (dash + gap);\n        dist -= dash + gap;\n    }\n}\nexports.dashLineTo = dashLineTo;\n/**\n * draw polygon\n */\nfunction drawPolygon(context, { pos, calcPoints, }, isTrigger = false) {\n    const lastPoint = calcPoints[calcPoints.length - 1];\n    const fromX = pos.x + lastPoint.x;\n    const fromY = pos.y + lastPoint.y;\n    if (calcPoints.length === 1) {\n        context.arc(fromX, fromY, 1, 0, Math.PI * 2);\n    }\n    else {\n        context.moveTo(fromX, fromY);\n    }\n    (0, optimized_1.forEach)(calcPoints, (point, index) => {\n        const toX = pos.x + point.x;\n        const toY = pos.y + point.y;\n        if (isTrigger) {\n            const prev = calcPoints[index - 1] || lastPoint;\n            dashLineTo(context, pos.x + prev.x, pos.y + prev.y, toX, toY);\n        }\n        else {\n            context.lineTo(toX, toY);\n        }\n    });\n}\nexports.drawPolygon = drawPolygon;\n/**\n * draw body bounding body box\n */\nfunction drawBVH(context, body) {\n    drawPolygon(context, {\n        pos: { x: body.minX, y: body.minY },\n        calcPoints: createBox(body.maxX - body.minX, body.maxY - body.minY),\n    });\n}\nexports.drawBVH = drawBVH;\n/**\n * clone response object returning new response with previous ones values\n */\nfunction cloneResponse(response) {\n    const clone = new sat_1.Response();\n    const { a, b, overlap, overlapN, overlapV, aInB, bInA } = response;\n    clone.a = a;\n    clone.b = b;\n    clone.overlap = overlap;\n    clone.overlapN = overlapN.clone();\n    clone.overlapV = overlapV.clone();\n    clone.aInB = aInB;\n    clone.bInA = bInA;\n    return clone;\n}\nexports.cloneResponse = cloneResponse;\n/**\n * dummy fn used as default, for optimization\n */\nfunction returnTrue() {\n    return true;\n}\nexports.returnTrue = returnTrue;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,UAAU,GAAGF,OAAO,CAACG,aAAa,GAAGH,OAAO,CAACI,OAAO,GAAGJ,OAAO,CAACK,WAAW,GAAGL,OAAO,CAACM,UAAU,GAAGN,OAAO,CAACO,UAAU,GAAGP,OAAO,CAACQ,kBAAkB,GAAGR,OAAO,CAACS,gBAAgB,GAAGT,OAAO,CAACU,gBAAgB,GAAGV,OAAO,CAACW,gBAAgB,GAAGX,OAAO,CAACY,SAAS,GAAGZ,OAAO,CAACa,aAAa,GAAGb,OAAO,CAACc,gBAAgB,GAAGd,OAAO,CAACe,SAAS,GAAGf,OAAO,CAACgB,UAAU,GAAGhB,OAAO,CAACiB,SAAS,GAAGjB,OAAO,CAACkB,QAAQ,GAAGlB,OAAO,CAACmB,mBAAmB,GAAGnB,OAAO,CAACoB,iBAAiB,GAAGpB,OAAO,CAACqB,SAAS,GAAGrB,OAAO,CAACsB,aAAa,GAAGtB,OAAO,CAACuB,OAAO,GAAGvB,OAAO,CAACwB,OAAO,GAAGxB,OAAO,CAACyB,OAAO,GAAGzB,OAAO,CAAC0B,OAAO,GAAG,KAAK,CAAC;AACxjB,MAAMC,KAAK,GAAGC,OAAO,CAAC,KAAK,CAAC;AAC5B,MAAMC,WAAW,GAAGD,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAME,OAAO,GAAGF,OAAO,CAAC,SAAS,CAAC;AAClC,MAAMG,WAAW,GAAGH,OAAO,CAAC,aAAa,CAAC;AAC1C;AACA,MAAMI,OAAO,GAAG;EACZC,eAAe,EAAEN,KAAK,CAACO,gBAAgB;EACvCC,gBAAgB,EAAER,KAAK,CAACS,iBAAiB;EACzCC,gBAAgB,EAAEV,KAAK,CAACW,iBAAiB;EACzCC,iBAAiB,EAAEZ,KAAK,CAACa,kBAAkB;EAC3CC,cAAc,EAAEZ,WAAW,CAACa,cAAc;EAC1CC,eAAe,EAAEd,WAAW,CAACe,eAAe;EAC5CC,eAAe,EAAEhB,WAAW,CAACiB,eAAe;EAC5CC,gBAAgB,EAAElB,WAAW,CAACmB;AAClC,CAAC;AACD,SAASC,SAASA,CAACC,QAAQ,EAAEC,QAAQ,EAAE;EACnC,OAAOrD,MAAM,CAACsD,MAAM,CAACtB,OAAO,CAACuB,QAAQ,CAAC,CAACC,MAAM,CAAC,CAACC,MAAM,EAAEC,IAAI,KAAM1D,MAAM,CAAC2D,MAAM,CAAC3D,MAAM,CAAC2D,MAAM,CAAC,CAAC,CAAC,EAAEF,MAAM,CAAC,EAAE;IAAE,CAACC,IAAI,GAAGA,IAAI,KAAK1B,OAAO,CAACuB,QAAQ,CAACK,MAAM,GAC1I1B,OAAO,CAAE,GAAEmB,QAAS,GAAED,QAAS,QAAO,CAAC,GACvClB,OAAO,CAAE,GAAEmB,QAAS,GAAED,QAAS,SAAQ;EAAE,CAAC,CAAE,EAAE,CAAC,CAAC,CAAC;AAC/D;AACA,MAAMS,kBAAkB,GAAGV,SAAS,CAACnB,OAAO,CAACuB,QAAQ,CAACK,MAAM,EAAE,KAAK,CAAC;AACpE,MAAME,iBAAiB,GAAGX,SAAS,CAACnB,OAAO,CAACuB,QAAQ,CAACK,MAAM,EAAE,IAAI,CAAC;AAClE,MAAMG,mBAAmB,GAAGZ,SAAS,CAACnB,OAAO,CAACuB,QAAQ,CAACS,OAAO,EAAE,KAAK,CAAC;AACtE,MAAMC,kBAAkB,GAAGd,SAAS,CAACnB,OAAO,CAACuB,QAAQ,CAACS,OAAO,EAAE,IAAI,CAAC;AACpE9D,OAAO,CAAC0B,OAAO,GAAGsC,IAAI,CAACC,EAAE,GAAG,GAAG;AAC/BjE,OAAO,CAACyB,OAAO,GAAG,GAAG,GAAGuC,IAAI,CAACC,EAAE;AAC/B;AACA;AACA;AACA,SAASzC,OAAOA,CAAC0C,OAAO,EAAE;EACtB,OAAOA,OAAO,GAAGlE,OAAO,CAAC0B,OAAO;AACpC;AACA1B,OAAO,CAACwB,OAAO,GAAGA,OAAO;AACzB;AACA;AACA;AACA,SAASD,OAAOA,CAAC4C,OAAO,EAAE;EACtB,OAAOA,OAAO,GAAGnE,OAAO,CAACyB,OAAO;AACpC;AACAzB,OAAO,CAACuB,OAAO,GAAGA,OAAO;AACzB;AACA;AACA;AACA,SAASD,aAAaA,CAAC8C,OAAO,EAAEC,OAAO,GAAGD,OAAO,EAAEE,IAAI,GAAG,CAAC,EAAE;EACzD,MAAMC,KAAK,GAAGP,IAAI,CAACC,EAAE,GAAGD,IAAI,CAACQ,KAAK,CAACJ,OAAO,EAAEC,OAAO,CAAC,GAAG,CAAC;EACxD,MAAMI,MAAM,GAAGT,IAAI,CAACU,GAAG,CAAC,CAAC,EAAEV,IAAI,CAACW,IAAI,CAACJ,KAAK,GAAGP,IAAI,CAACU,GAAG,CAAC,CAAC,EAAEJ,IAAI,CAAC,CAAC,CAAC;EAChE,MAAMM,OAAO,GAAG,EAAE;EAClB,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGJ,MAAM,EAAEI,KAAK,EAAE,EAAE;IACzC,MAAM5E,KAAK,GAAI4E,KAAK,GAAGJ,MAAM,GAAI,CAAC,GAAGT,IAAI,CAACC,EAAE;IAC5C,MAAMa,CAAC,GAAGd,IAAI,CAACe,GAAG,CAAC9E,KAAK,CAAC,GAAGmE,OAAO;IACnC,MAAMY,CAAC,GAAGhB,IAAI,CAACiB,GAAG,CAAChF,KAAK,CAAC,GAAGoE,OAAO;IACnCO,OAAO,CAACM,IAAI,CAAC,IAAIvD,KAAK,CAACwD,MAAM,CAACL,CAAC,EAAEE,CAAC,CAAC,CAAC;EACxC;EACA,OAAOJ,OAAO;AAClB;AACA5E,OAAO,CAACsB,aAAa,GAAGA,aAAa;AACrC;AACA;AACA;AACA,SAASD,SAASA,CAAC+D,KAAK,EAAEC,MAAM,EAAE;EAC9B,OAAO,CACH,IAAI1D,KAAK,CAACwD,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,EACtB,IAAIxD,KAAK,CAACwD,MAAM,CAACC,KAAK,EAAE,CAAC,CAAC,EAC1B,IAAIzD,KAAK,CAACwD,MAAM,CAACC,KAAK,EAAEC,MAAM,CAAC,EAC/B,IAAI1D,KAAK,CAACwD,MAAM,CAAC,CAAC,EAAEE,MAAM,CAAC,CAC9B;AACL;AACArF,OAAO,CAACqB,SAAS,GAAGA,SAAS;AAC7B;AACA;AACA;AACA,SAASD,iBAAiBA,CAACkE,KAAK,GAAG,CAAC,CAAC,EAAE;EACnC,OAAOA,KAAK,YAAY3D,KAAK,CAACwD,MAAM,GAC9BG,KAAK,GACL,IAAI3D,KAAK,CAACwD,MAAM,CAACG,KAAK,CAACR,CAAC,IAAI,CAAC,EAAEQ,KAAK,CAACN,CAAC,IAAI,CAAC,CAAC;AACtD;AACAhF,OAAO,CAACoB,iBAAiB,GAAGA,iBAAiB;AAC7C;AACA;AACA;AACA,SAASD,mBAAmBA,CAACoE,MAAM,GAAG,EAAE,EAAE;EACtC,MAAMC,aAAa,GAAG,CAAC,CAAC,EAAEzD,WAAW,CAAC0D,GAAG,EAAEF,MAAM,EAAEnE,iBAAiB,CAAC;EACrE,OAAOH,SAAS,CAACuE,aAAa,CAAC,GAAGA,aAAa,CAACE,OAAO,CAAC,CAAC,GAAGF,aAAa;AAC7E;AACAxF,OAAO,CAACmB,mBAAmB,GAAGA,mBAAmB;AACjD;AACA;AACA;AACA,SAASD,QAAQA,CAACyE,KAAK,EAAEC,KAAK,EAAE;EAC5B,MAAMC,KAAK,GAAGF,KAAK,CAACb,CAAC,GAAGc,KAAK,CAACd,CAAC;EAC/B,MAAMgB,KAAK,GAAGH,KAAK,CAACX,CAAC,GAAGY,KAAK,CAACZ,CAAC;EAC/B,OAAOhB,IAAI,CAACQ,KAAK,CAACqB,KAAK,EAAEC,KAAK,CAAC;AACnC;AACA9F,OAAO,CAACkB,QAAQ,GAAGA,QAAQ;AAC3B;AACA;AACA;AACA,SAASD,SAASA,CAACsE,MAAM,EAAE;EACvB,MAAMd,MAAM,GAAGc,MAAM,CAACd,MAAM;EAC5B,IAAIsB,GAAG,GAAG,CAAC;EACX,CAAC,CAAC,EAAEhE,WAAW,CAACiE,OAAO,EAAET,MAAM,EAAE,CAACU,EAAE,EAAEpB,KAAK,KAAK;IAC5C,MAAMqB,EAAE,GAAGX,MAAM,CAAC,CAACV,KAAK,GAAG,CAAC,IAAIJ,MAAM,CAAC;IACvCsB,GAAG,IAAI,CAACG,EAAE,CAACpB,CAAC,GAAGmB,EAAE,CAACnB,CAAC,KAAKoB,EAAE,CAAClB,CAAC,GAAGiB,EAAE,CAACjB,CAAC,CAAC;EACxC,CAAC,CAAC;EACF,OAAOe,GAAG,GAAG,CAAC;AAClB;AACA/F,OAAO,CAACiB,SAAS,GAAGA,SAAS;AAC7B;AACA;AACA;AACA,SAASD,UAAUA,CAACmF,IAAI,EAAEC,OAAO,EAAE;EAC/BD,IAAI,CAACE,QAAQ,GAAG,CAAC,EAAED,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACC,QAAQ,CAAC;EACtFF,IAAI,CAACG,SAAS,GAAG,CAAC,EAAEF,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACE,SAAS,CAAC;EACxFH,IAAI,CAACI,OAAO,GAAG,CAACH,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACG,OAAO,KAAK,CAAC;EACvF,IAAIJ,IAAI,CAAC3C,IAAI,KAAK1B,OAAO,CAACuB,QAAQ,CAACK,MAAM,EAAE;IACvCyC,IAAI,CAACK,UAAU,GAAG,CAACJ,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACI,UAAU,KAAK,KAAK;EACrG;EACAL,IAAI,CAACM,QAAQ,CAAC,CAACL,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACM,KAAK,KAAK,CAAC,CAAC;AACzF;AACA1G,OAAO,CAACgB,UAAU,GAAGA,UAAU;AAC/B;AACA;AACA;AACA,SAASD,SAASA,CAACoF,IAAI,EAAE;EACrB,MAAM;IAAEQ,IAAI;IAAEC,IAAI;IAAEC,IAAI;IAAEC,IAAI;IAAEC;EAAK,CAAC,GAAGZ,IAAI;EAC7C,OAAQQ,IAAI,CAACC,IAAI,GAAGA,IAAI,IAAID,IAAI,CAACE,IAAI,GAAGA,IAAI,IAAIF,IAAI,CAACG,IAAI,GAAGA,IAAI,IAAIH,IAAI,CAACI,IAAI,GAAGA,IAAI;AACxF;AACA/G,OAAO,CAACe,SAAS,GAAGA,SAAS;AAC7B;AACA;AACA;AACA,SAASD,gBAAgBA,CAAC6E,KAAK,EAAEC,KAAK,EAAE;EACpC,OAAQA,KAAK,CAACgB,IAAI,GAAGjB,KAAK,CAACmB,IAAI,IAC3BlB,KAAK,CAACiB,IAAI,GAAGlB,KAAK,CAACoB,IAAI,IACvBnB,KAAK,CAACkB,IAAI,GAAGnB,KAAK,CAACiB,IAAI,IACvBhB,KAAK,CAACmB,IAAI,GAAGpB,KAAK,CAACkB,IAAI;AAC/B;AACA7G,OAAO,CAACc,gBAAgB,GAAGA,gBAAgB;AAC3C;AACA;AACA;AACA,SAASD,aAAaA,CAAC8E,KAAK,EAAEC,KAAK,EAAE;EACjC,OAAO,CAAC9E,gBAAgB,CAAC6E,KAAK,EAAEC,KAAK,CAAC;AAC1C;AACA5F,OAAO,CAACa,aAAa,GAAGA,aAAa;AACrC;AACA;AACA;AACA,SAASD,SAASA,CAAC+E,KAAK,EAAEC,KAAK,EAAE;EAC7B,MAAMoB,KAAK,GAAGrB,KAAK,CAACnC,IAAI,KAAK1B,OAAO,CAACuB,QAAQ,CAACK,MAAM,GAAGE,iBAAiB,GAAGG,kBAAkB;EAC7F,OAAOiD,KAAK,CAACpB,KAAK,CAACpC,IAAI,CAAC,CAACmC,KAAK,EAAEC,KAAK,CAAC;AAC1C;AACA5F,OAAO,CAACY,SAAS,GAAGA,SAAS;AAC7B;AACA;AACA;AACA,SAASD,gBAAgBA,CAAC4E,MAAM,EAAE;EAC9B,OAAO,CAAC,CAAC,EAAExD,WAAW,CAAC0D,GAAG,EAAEF,MAAM,EAAE,CAAC;IAAET,CAAC;IAAEE;EAAE,CAAC,MAAM;IAAEF,CAAC;IAAEE;EAAE,CAAC,CAAC,CAAC;AACjE;AACAhF,OAAO,CAACW,gBAAgB,GAAGA,gBAAgB;AAC3C;AACA;AACA;AACA,SAASD,gBAAgBA,CAAC;EAAEoE,CAAC;EAAEE;AAAE,CAAC,GAAG;EAAEF,CAAC,EAAE,CAAC;EAAEE,CAAC,EAAE;AAAE,CAAC,EAAE;EACjD,OAAO,CAACF,CAAC,EAAEE,CAAC,CAAC;AACjB;AACAhF,OAAO,CAACU,gBAAgB,GAAGA,gBAAgB;AAC3C;AACA;AACA;AACA,SAASD,gBAAgBA,CAAC,CAACqE,CAAC,EAAEE,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE;EACvC,OAAO;IAAEF,CAAC;IAAEE;EAAE,CAAC;AACnB;AACAhF,OAAO,CAACS,gBAAgB,GAAGA,gBAAgB;AAC3C;AACA;AACA;AACA,SAASD,kBAAkBA,CAAC2F,IAAI,EAAEc,QAAQ,EAAE;EACxC,MAAMf,EAAE,GAAG,IAAIvE,KAAK,CAACwD,MAAM,CAAC8B,QAAQ,CAACnC,CAAC,GAAGqB,IAAI,CAACrB,CAAC,EAAEmC,QAAQ,CAACjC,CAAC,GAAGmB,IAAI,CAACnB,CAAC,CAAC;EACrE,MAAMiB,EAAE,GAAG,IAAItE,KAAK,CAACwD,MAAM,CAACgB,IAAI,CAACrB,CAAC,GAAGmC,QAAQ,CAACnC,CAAC,EAAEqB,IAAI,CAACnB,CAAC,GAAGiC,QAAQ,CAACjC,CAAC,CAAC;EACrE,MAAMkC,GAAG,GAAGjB,EAAE,CAACkB,GAAG,CAACjB,EAAE,CAACkB,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC;EACtC,OAAO,IAAIzF,KAAK,CAACwD,MAAM,CAACe,EAAE,CAACpB,CAAC,GAAGoC,GAAG,GAAGjB,EAAE,CAACnB,CAAC,EAAEoB,EAAE,CAAClB,CAAC,GAAGkC,GAAG,GAAGjB,EAAE,CAACjB,CAAC,CAAC,CAACoC,SAAS,CAAC,CAAC;AAC7E;AACApH,OAAO,CAACQ,kBAAkB,GAAGA,kBAAkB;AAC/C;AACA;AACA;AACA,SAASD,UAAUA,CAACoF,KAAK,EAAEC,KAAK,EAAE;EAC9B,MAAMoB,KAAK,GAAGrB,KAAK,CAACnC,IAAI,KAAK1B,OAAO,CAACuB,QAAQ,CAACK,MAAM,GAAGC,kBAAkB,GAAGE,mBAAmB;EAC/F,OAAOmD,KAAK,CAACpB,KAAK,CAACpC,IAAI,CAAC;AAC5B;AACAxD,OAAO,CAACO,UAAU,GAAGA,UAAU;AAC/B;AACA;AACA;AACA,SAASD,UAAUA,CAAC+G,OAAO,EAAEC,KAAK,EAAEC,KAAK,EAAEC,GAAG,EAAEC,GAAG,EAAEC,IAAI,GAAG,CAAC,EAAEC,GAAG,GAAG,CAAC,EAAE;EACpE,MAAM9B,KAAK,GAAG2B,GAAG,GAAGF,KAAK;EACzB,MAAMxB,KAAK,GAAG2B,GAAG,GAAGF,KAAK;EACzB,MAAMK,GAAG,GAAG5D,IAAI,CAAC6D,KAAK,CAAC/B,KAAK,EAAED,KAAK,CAAC;EACpC,MAAMiC,OAAO,GAAG9D,IAAI,CAACe,GAAG,CAAC6C,GAAG,CAAC;EAC7B,MAAMG,OAAO,GAAG/D,IAAI,CAACiB,GAAG,CAAC2C,GAAG,CAAC;EAC7B,IAAII,IAAI,GAAGV,KAAK;EAChB,IAAIW,IAAI,GAAGV,KAAK;EAChB,IAAIW,IAAI,GAAGlE,IAAI,CAACQ,KAAK,CAACqB,KAAK,EAAEC,KAAK,CAAC;EACnC,OAAOoC,IAAI,GAAG,CAAC,EAAE;IACb,MAAM5D,IAAI,GAAGN,IAAI,CAACmE,GAAG,CAACD,IAAI,EAAER,IAAI,CAAC;IACjCL,OAAO,CAACe,MAAM,CAACJ,IAAI,EAAEC,IAAI,CAAC;IAC1BZ,OAAO,CAACgB,MAAM,CAACL,IAAI,GAAGF,OAAO,GAAGxD,IAAI,EAAE2D,IAAI,GAAGF,OAAO,GAAGzD,IAAI,CAAC;IAC5D0D,IAAI,IAAIF,OAAO,IAAIJ,IAAI,GAAGC,GAAG,CAAC;IAC9BM,IAAI,IAAIF,OAAO,IAAIL,IAAI,GAAGC,GAAG,CAAC;IAC9BO,IAAI,IAAIR,IAAI,GAAGC,GAAG;EACtB;AACJ;AACA3H,OAAO,CAACM,UAAU,GAAGA,UAAU;AAC/B;AACA;AACA;AACA,SAASD,WAAWA,CAACgH,OAAO,EAAE;EAAEiB,GAAG;EAAEC;AAAY,CAAC,EAAEjC,SAAS,GAAG,KAAK,EAAE;EACnE,MAAMkC,SAAS,GAAGD,UAAU,CAACA,UAAU,CAAC9D,MAAM,GAAG,CAAC,CAAC;EACnD,MAAM6C,KAAK,GAAGgB,GAAG,CAACxD,CAAC,GAAG0D,SAAS,CAAC1D,CAAC;EACjC,MAAMyC,KAAK,GAAGe,GAAG,CAACtD,CAAC,GAAGwD,SAAS,CAACxD,CAAC;EACjC,IAAIuD,UAAU,CAAC9D,MAAM,KAAK,CAAC,EAAE;IACzB4C,OAAO,CAACO,GAAG,CAACN,KAAK,EAAEC,KAAK,EAAE,CAAC,EAAE,CAAC,EAAEvD,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;EAChD,CAAC,MACI;IACDoD,OAAO,CAACe,MAAM,CAACd,KAAK,EAAEC,KAAK,CAAC;EAChC;EACA,CAAC,CAAC,EAAExF,WAAW,CAACiE,OAAO,EAAEuC,UAAU,EAAE,CAACjD,KAAK,EAAET,KAAK,KAAK;IACnD,MAAM2C,GAAG,GAAGc,GAAG,CAACxD,CAAC,GAAGQ,KAAK,CAACR,CAAC;IAC3B,MAAM2C,GAAG,GAAGa,GAAG,CAACtD,CAAC,GAAGM,KAAK,CAACN,CAAC;IAC3B,IAAIsB,SAAS,EAAE;MACX,MAAMmC,IAAI,GAAGF,UAAU,CAAC1D,KAAK,GAAG,CAAC,CAAC,IAAI2D,SAAS;MAC/ClI,UAAU,CAAC+G,OAAO,EAAEiB,GAAG,CAACxD,CAAC,GAAG2D,IAAI,CAAC3D,CAAC,EAAEwD,GAAG,CAACtD,CAAC,GAAGyD,IAAI,CAACzD,CAAC,EAAEwC,GAAG,EAAEC,GAAG,CAAC;IACjE,CAAC,MACI;MACDJ,OAAO,CAACgB,MAAM,CAACb,GAAG,EAAEC,GAAG,CAAC;IAC5B;EACJ,CAAC,CAAC;AACN;AACAzH,OAAO,CAACK,WAAW,GAAGA,WAAW;AACjC;AACA;AACA;AACA,SAASD,OAAOA,CAACiH,OAAO,EAAElB,IAAI,EAAE;EAC5B9F,WAAW,CAACgH,OAAO,EAAE;IACjBiB,GAAG,EAAE;MAAExD,CAAC,EAAEqB,IAAI,CAACS,IAAI;MAAE5B,CAAC,EAAEmB,IAAI,CAACU;IAAK,CAAC;IACnC0B,UAAU,EAAElH,SAAS,CAAC8E,IAAI,CAACW,IAAI,GAAGX,IAAI,CAACS,IAAI,EAAET,IAAI,CAACY,IAAI,GAAGZ,IAAI,CAACU,IAAI;EACtE,CAAC,CAAC;AACN;AACA7G,OAAO,CAACI,OAAO,GAAGA,OAAO;AACzB;AACA;AACA;AACA,SAASD,aAAaA,CAACuI,QAAQ,EAAE;EAC7B,MAAMC,KAAK,GAAG,IAAIhH,KAAK,CAACiH,QAAQ,CAAC,CAAC;EAClC,MAAM;IAAEC,CAAC;IAAEC,CAAC;IAAEC,OAAO;IAAEC,QAAQ;IAAEC,QAAQ;IAAEC,IAAI;IAAEC;EAAK,CAAC,GAAGT,QAAQ;EAClEC,KAAK,CAACE,CAAC,GAAGA,CAAC;EACXF,KAAK,CAACG,CAAC,GAAGA,CAAC;EACXH,KAAK,CAACI,OAAO,GAAGA,OAAO;EACvBJ,KAAK,CAACK,QAAQ,GAAGA,QAAQ,CAACL,KAAK,CAAC,CAAC;EACjCA,KAAK,CAACM,QAAQ,GAAGA,QAAQ,CAACN,KAAK,CAAC,CAAC;EACjCA,KAAK,CAACO,IAAI,GAAGA,IAAI;EACjBP,KAAK,CAACQ,IAAI,GAAGA,IAAI;EACjB,OAAOR,KAAK;AAChB;AACA3I,OAAO,CAACG,aAAa,GAAGA,aAAa;AACrC;AACA;AACA;AACA,SAASD,UAAUA,CAAA,EAAG;EAClB,OAAO,IAAI;AACf;AACAF,OAAO,CAACE,UAAU,GAAGA,UAAU","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}