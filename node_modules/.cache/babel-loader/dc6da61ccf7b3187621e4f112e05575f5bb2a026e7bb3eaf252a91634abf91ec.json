{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\gaspa\\\\OneDrive\\\\Documents\\\\MMI 2\\\\S4\\\\React\\\\SpinningWheel\\\\spin-wheel\\\\src\\\\components\\\\SpinWheel.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect } from 'react';\nimport './css/wheel.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst pointer = /*#__PURE__*/_jsxDEV(\"line\", {\n  x1: \"50\",\n  y1: \"10\",\n  x2: \"50\",\n  y2: \"0\",\n  stroke: \"red\",\n  strokeWidth: \"2\"\n}, void 0, false, {\n  fileName: _jsxFileName,\n  lineNumber: 5,\n  columnNumber: 3\n}, this);\nconst RouletteGame = () => {\n  _s();\n  const [fields, setFields] = useState([]);\n  const [rotation, setRotation] = useState(0);\n  const [pointerAngle, setPointerAngle] = useState(0);\n  const [isSpinning, setIsSpinning] = useState(false);\n  const [result, setResult] = useState(null);\n  const wheelRef = useRef(null);\n  const pointerRef = useRef(null);\n  useEffect(() => {\n    // Initialize the roulette sections\n    initializeSections();\n  }, []);\n  const initializeSections = () => {\n    const numberOfSections = 8; // Change this to the desired number of sections\n\n    const newFields = Array.from({\n      length: numberOfSections\n    }, (_, index) => ({\n      id: index + 1,\n      name: `Section ${index + 1}`,\n      color: getRandomColor()\n    }));\n    setFields(newFields);\n  };\n  const getRandomColor = () => {\n    return `#${Math.floor(Math.random() * 16777215).toString(16)}`;\n  };\n  const calculatePath = index => {\n    const totalFields = fields.length;\n    const angle = 360 / totalFields * index;\n    const startAngle = angle;\n    const endAngle = angle + 360 / totalFields;\n    const radius = 50;\n    const startX = 50 + radius * Math.cos(startAngle * Math.PI / 180);\n    const startY = 50 + radius * Math.sin(startAngle * Math.PI / 180);\n    const endX = 50 + radius * Math.cos(endAngle * Math.PI / 180);\n    const endY = 50 + radius * Math.sin(endAngle * Math.PI / 180);\n    const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;\n    const color = fields[index].color;\n    const textX = 50 + radius * 0.8 * Math.cos((startAngle + endAngle) / 2 * (Math.PI / 180));\n    const textY = 50 + radius * 0.8 * Math.sin((startAngle + endAngle) / 2 * (Math.PI / 180));\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"path\", {\n        d: `M50 50 L${startX} ${startY} A${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY} Z`,\n        fill: color,\n        stroke: \"black\",\n        strokeWidth: \"1\"\n      }, index, false, {\n        fileName: _jsxFileName,\n        lineNumber: 60,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"text\", {\n        x: textX,\n        y: textY,\n        fontSize: \"5\",\n        textAnchor: \"middle\",\n        fill: \"black\",\n        children: fields[index].name\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 67,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true);\n  };\n  const handleStartSpin = () => {\n    setResult(null);\n    setIsSpinning(true);\n    const totalDuration = 3000;\n    const start = Date.now();\n    const spinAnimation = () => {\n      const elapsed = Date.now() - start;\n      const progress = Math.min(elapsed / totalDuration, 1);\n      const easedProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);\n      const rotation = 1080 * easedProgress;\n      setRotation(rotation);\n    };\n    const spinInterval = setInterval(spinAnimation, 16);\n    setTimeout(() => {\n      clearInterval(spinInterval);\n      setIsSpinning(false);\n\n      // Determine the result after spinning stops\n      detectSectionOnRotation();\n    }, totalDuration + 100);\n  };\n  const detectSectionOnRotation = () => {\n    const wheelRect = wheelRef.current.getBoundingClientRect();\n    const wheelCenterX = wheelRect.left + wheelRect.width / 2;\n    const wheelCenterY = wheelRect.top + wheelRect.height / 2;\n\n    // Utiliser un angle aléatoire comme point d'arrêt pour le résultat\n    const stopAngle = Math.floor(Math.random() * 360);\n    const angle = Math.atan2(wheelCenterY, wheelCenterX) * (180 / Math.PI);\n    const normalizedAngle = (angle + 360) % 360;\n    const sectionAngle = 360 / fields.length;\n    const selectedSectionIndex = Math.floor(normalizedAngle / sectionAngle);\n\n    // Faire tourner la roue jusqu'à ce que l'angle cible soit atteint\n    const rotateToTargetAngle = (currentRotation, targetAngle) => {\n      const rotationSpeed = 10;\n      const angleDifference = targetAngle - currentRotation;\n      if (Math.abs(angleDifference) <= rotationSpeed) {\n        setRotation(targetAngle);\n        setResult(selectedSectionIndex !== null ? selectedSectionIndex : 0);\n        return;\n      }\n      const newRotation = currentRotation + (angleDifference > 0 ? rotationSpeed : -rotationSpeed);\n      setRotation(newRotation);\n      requestAnimationFrame(() => rotateToTargetAngle(newRotation, targetAngle));\n    };\n    rotateToTargetAngle(rotation, stopAngle);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"roulette-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Roulette Spin Wheel\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 138,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"roulette\",\n      ref: wheelRef,\n      children: /*#__PURE__*/_jsxDEV(\"svg\", {\n        viewBox: \"0 0 100 100\",\n        width: \"200\",\n        height: \"200\",\n        children: [/*#__PURE__*/_jsxDEV(\"g\", {\n          transform: `rotate(${rotation} 50 50)`,\n          children: fields.map((_, index) => calculatePath(index))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 141,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"g\", {\n          transform: `rotate(${pointerAngle} 50 50)`,\n          ref: pointerRef,\n          children: pointer\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 144,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 140,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 139,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: handleStartSpin,\n      disabled: isSpinning,\n      children: \"Lancer la roue\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 150,\n      columnNumber: 7\n    }, this), result !== null && /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"R\\xE9sultat: \", fields[result].name]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 153,\n      columnNumber: 27\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 137,\n    columnNumber: 5\n  }, this);\n};\n_s(RouletteGame, \"3wVV1P3qFtPc8x+Ke1yatM15d/Y=\");\n_c = RouletteGame;\nexport default RouletteGame;\nvar _c;\n$RefreshReg$(_c, \"RouletteGame\");","map":{"version":3,"names":["React","useState","useRef","useEffect","jsxDEV","_jsxDEV","Fragment","_Fragment","pointer","x1","y1","x2","y2","stroke","strokeWidth","fileName","_jsxFileName","lineNumber","columnNumber","RouletteGame","_s","fields","setFields","rotation","setRotation","pointerAngle","setPointerAngle","isSpinning","setIsSpinning","result","setResult","wheelRef","pointerRef","initializeSections","numberOfSections","newFields","Array","from","length","_","index","id","name","color","getRandomColor","Math","floor","random","toString","calculatePath","totalFields","angle","startAngle","endAngle","radius","startX","cos","PI","startY","sin","endX","endY","largeArcFlag","textX","textY","children","d","fill","x","y","fontSize","textAnchor","handleStartSpin","totalDuration","start","Date","now","spinAnimation","elapsed","progress","min","easedProgress","spinInterval","setInterval","setTimeout","clearInterval","detectSectionOnRotation","wheelRect","current","getBoundingClientRect","wheelCenterX","left","width","wheelCenterY","top","height","stopAngle","atan2","normalizedAngle","sectionAngle","selectedSectionIndex","rotateToTargetAngle","currentRotation","targetAngle","rotationSpeed","angleDifference","abs","newRotation","requestAnimationFrame","className","ref","viewBox","transform","map","onClick","disabled","_c","$RefreshReg$"],"sources":["C:/Users/gaspa/OneDrive/Documents/MMI 2/S4/React/SpinningWheel/spin-wheel/src/components/SpinWheel.jsx"],"sourcesContent":["import React, { useState, useRef, useEffect } from 'react';\r\nimport './css/wheel.css';\r\n\r\nconst pointer = (\r\n  <line x1=\"50\" y1=\"10\" x2=\"50\" y2=\"0\" stroke=\"red\" strokeWidth=\"2\" />\r\n);\r\n\r\nconst RouletteGame = () => {\r\n  const [fields, setFields] = useState([]);\r\n  const [rotation, setRotation] = useState(0);\r\n  const [pointerAngle, setPointerAngle] = useState(0);\r\n  const [isSpinning, setIsSpinning] = useState(false);\r\n  const [result, setResult] = useState(null);\r\n\r\n  const wheelRef = useRef(null);\r\n  const pointerRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    // Initialize the roulette sections\r\n    initializeSections();\r\n  }, []);\r\n\r\n  const initializeSections = () => {\r\n    const numberOfSections = 8; // Change this to the desired number of sections\r\n\r\n    const newFields = Array.from({ length: numberOfSections }, (_, index) => ({\r\n      id: index + 1,\r\n      name: `Section ${index + 1}`,\r\n      color: getRandomColor(),\r\n    }));\r\n\r\n    setFields(newFields);\r\n  };\r\n\r\n  const getRandomColor = () => {\r\n    return `#${Math.floor(Math.random() * 16777215).toString(16)}`;\r\n  };\r\n\r\n  const calculatePath = (index) => {\r\n    const totalFields = fields.length;\r\n    const angle = (360 / totalFields) * index;\r\n    const startAngle = angle;\r\n    const endAngle = angle + (360 / totalFields);\r\n\r\n    const radius = 50;\r\n\r\n    const startX = 50 + radius * Math.cos((startAngle * Math.PI) / 180);\r\n    const startY = 50 + radius * Math.sin((startAngle * Math.PI) / 180);\r\n    const endX = 50 + radius * Math.cos((endAngle * Math.PI) / 180);\r\n    const endY = 50 + radius * Math.sin((endAngle * Math.PI) / 180);\r\n\r\n    const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;\r\n    const color = fields[index].color;\r\n\r\n    const textX = 50 + radius * 0.8 * Math.cos(((startAngle + endAngle) / 2) * (Math.PI / 180));\r\n    const textY = 50 + radius * 0.8 * Math.sin(((startAngle + endAngle) / 2) * (Math.PI / 180));\r\n\r\n    return (\r\n      <>\r\n        <path\r\n          key={index}\r\n          d={`M50 50 L${startX} ${startY} A${radius} ${radius} 0 ${largeArcFlag} 1 ${endX} ${endY} Z`}\r\n          fill={color}\r\n          stroke=\"black\"\r\n          strokeWidth=\"1\"\r\n        />\r\n        <text x={textX} y={textY} fontSize=\"5\" textAnchor=\"middle\" fill=\"black\">\r\n          {fields[index].name}\r\n        </text>\r\n      </>\r\n    );\r\n  };\r\n\r\n  const handleStartSpin = () => {\r\n    setResult(null);\r\n    setIsSpinning(true);\r\n\r\n    const totalDuration = 3000;\r\n    const start = Date.now();\r\n\r\n    const spinAnimation = () => {\r\n      const elapsed = Date.now() - start;\r\n      const progress = Math.min(elapsed / totalDuration, 1);\r\n      const easedProgress = 0.5 - 0.5 * Math.cos(progress * Math.PI);\r\n\r\n      const rotation = 1080 * easedProgress;\r\n      setRotation(rotation);\r\n    };\r\n\r\n    const spinInterval = setInterval(spinAnimation, 16);\r\n\r\n    setTimeout(() => {\r\n      clearInterval(spinInterval);\r\n      setIsSpinning(false);\r\n\r\n      // Determine the result after spinning stops\r\n      detectSectionOnRotation();\r\n    }, totalDuration + 100);\r\n  };\r\n\r\n  const detectSectionOnRotation = () => {\r\n    const wheelRect = wheelRef.current.getBoundingClientRect();\r\n\r\n    const wheelCenterX = wheelRect.left + wheelRect.width / 2;\r\n    const wheelCenterY = wheelRect.top + wheelRect.height / 2;\r\n\r\n    // Utiliser un angle aléatoire comme point d'arrêt pour le résultat\r\n    const stopAngle = Math.floor(Math.random() * 360);\r\n\r\n    const angle = Math.atan2(wheelCenterY, wheelCenterX) * (180 / Math.PI);\r\n    const normalizedAngle = (angle + 360) % 360;\r\n\r\n    const sectionAngle = 360 / fields.length;\r\n    const selectedSectionIndex = Math.floor(normalizedAngle / sectionAngle);\r\n\r\n    // Faire tourner la roue jusqu'à ce que l'angle cible soit atteint\r\n    const rotateToTargetAngle = (currentRotation, targetAngle) => {\r\n      const rotationSpeed = 10;\r\n      const angleDifference = targetAngle - currentRotation;\r\n\r\n      if (Math.abs(angleDifference) <= rotationSpeed) {\r\n        setRotation(targetAngle);\r\n        setResult(selectedSectionIndex !== null ? selectedSectionIndex : 0);\r\n        return;\r\n      }\r\n\r\n      const newRotation = currentRotation + (angleDifference > 0 ? rotationSpeed : -rotationSpeed);\r\n      setRotation(newRotation);\r\n\r\n      requestAnimationFrame(() => rotateToTargetAngle(newRotation, targetAngle));\r\n    };\r\n\r\n    rotateToTargetAngle(rotation, stopAngle);\r\n  };\r\n\r\n  return (\r\n    <div className=\"roulette-container\">\r\n      <h2>Roulette Spin Wheel</h2>\r\n      <div className=\"roulette\" ref={wheelRef}>\r\n        <svg viewBox=\"0 0 100 100\" width=\"200\" height=\"200\">\r\n          <g transform={`rotate(${rotation} 50 50)`}>\r\n            {fields.map((_, index) => calculatePath(index))}\r\n          </g>\r\n          <g transform={`rotate(${pointerAngle} 50 50)`} ref={pointerRef}>\r\n            {pointer}\r\n          </g>\r\n        </svg>\r\n      </div>\r\n\r\n      <button onClick={handleStartSpin} disabled={isSpinning}>\r\n        Lancer la roue\r\n      </button>\r\n      {result !== null && <p>Résultat: {fields[result].name}</p>}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default RouletteGame;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}