{"ast":null,"code":"// Version 0.9.0 - Copyright 2012 - 2021 -  Jim Riecken <jimr@jimr.ca>\n//\n// Released under the MIT License - https://github.com/jriecken/sat-js\n//\n// A simple library for determining intersections of circles and\n// polygons using the Separating Axis Theorem.\n/** @preserve SAT.js - Version 0.9.0 - Copyright 2012 - 2021 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */\n\n/*global define: false, module: false*/\n/*jshint shadow:true, sub:true, forin:true, noarg:true, noempty:true,\n  eqeqeq:true, bitwise:true, strict:true, undef:true,\n  curly:true, browser:true */\n\n// Create a UMD wrapper for SAT. Works in:\n//\n//  - Plain browser via global SAT variable\n//  - AMD loader (like require.js)\n//  - Node.js\n//\n// The quoted properties all over the place are used so that the Closure Compiler\n// does not mangle the exposed API in advanced mode.\n/**\n * @param {*} root - The global scope\n * @param {Function} factory - Factory that creates SAT module\n */\n(function (root, factory) {\n  \"use strict\";\n\n  if (typeof define === 'function' && define['amd']) {\n    define(factory);\n  } else if (typeof exports === 'object') {\n    module['exports'] = factory();\n  } else {\n    root['SAT'] = factory();\n  }\n})(this, function () {\n  \"use strict\";\n\n  var SAT = {};\n\n  //\n  // ## Vector\n  //\n  // Represents a vector in two dimensions with `x` and `y` properties.\n\n  // Create a new Vector, optionally passing in the `x` and `y` coordinates. If\n  // a coordinate is not specified, it will be set to `0`\n  /**\n   * @param {?number=} x The x position.\n   * @param {?number=} y The y position.\n   * @constructor\n   */\n  function Vector(x, y) {\n    this['x'] = x || 0;\n    this['y'] = y || 0;\n  }\n  SAT['Vector'] = Vector;\n  // Alias `Vector` as `V`\n  SAT['V'] = Vector;\n\n  // Copy the values of another Vector into this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['copy'] = Vector.prototype.copy = function (other) {\n    this['x'] = other['x'];\n    this['y'] = other['y'];\n    return this;\n  };\n\n  // Create a new vector with the same coordinates as this on.\n  /**\n   * @return {Vector} The new cloned vector\n   */\n  Vector.prototype['clone'] = Vector.prototype.clone = function () {\n    return new Vector(this['x'], this['y']);\n  };\n\n  // Change this vector to be perpendicular to what it was before. (Effectively\n  // roatates it 90 degrees in a clockwise direction)\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['perp'] = Vector.prototype.perp = function () {\n    var x = this['x'];\n    this['x'] = this['y'];\n    this['y'] = -x;\n    return this;\n  };\n\n  // Rotate this vector (counter-clockwise) by the specified angle (in radians).\n  /**\n   * @param {number} angle The angle to rotate (in radians)\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['rotate'] = Vector.prototype.rotate = function (angle) {\n    var x = this['x'];\n    var y = this['y'];\n    this['x'] = x * Math.cos(angle) - y * Math.sin(angle);\n    this['y'] = x * Math.sin(angle) + y * Math.cos(angle);\n    return this;\n  };\n\n  // Reverse this vector.\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reverse'] = Vector.prototype.reverse = function () {\n    this['x'] = -this['x'];\n    this['y'] = -this['y'];\n    return this;\n  };\n\n  // Normalize this vector.  (make it have length of `1`)\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['normalize'] = Vector.prototype.normalize = function () {\n    var d = this.len();\n    if (d > 0) {\n      this['x'] = this['x'] / d;\n      this['y'] = this['y'] / d;\n    }\n    return this;\n  };\n\n  // Add another vector to this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['add'] = Vector.prototype.add = function (other) {\n    this['x'] += other['x'];\n    this['y'] += other['y'];\n    return this;\n  };\n\n  // Subtract another vector from this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaiing.\n   */\n  Vector.prototype['sub'] = Vector.prototype.sub = function (other) {\n    this['x'] -= other['x'];\n    this['y'] -= other['y'];\n    return this;\n  };\n\n  // Scale this vector. An independent scaling factor can be provided\n  // for each axis, or a single scaling factor that will scale both `x` and `y`.\n  /**\n   * @param {number} x The scaling factor in the x direction.\n   * @param {?number=} y The scaling factor in the y direction.  If this\n   *   is not specified, the x scaling factor will be used.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['scale'] = Vector.prototype.scale = function (x, y) {\n    this['x'] *= x;\n    this['y'] *= typeof y != 'undefined' ? y : x;\n    return this;\n  };\n\n  // Project this vector on to another vector.\n  /**\n   * @param {Vector} other The vector to project onto.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['project'] = Vector.prototype.project = function (other) {\n    var amt = this.dot(other) / other.len2();\n    this['x'] = amt * other['x'];\n    this['y'] = amt * other['y'];\n    return this;\n  };\n\n  // Project this vector onto a vector of unit length. This is slightly more efficient\n  // than `project` when dealing with unit vectors.\n  /**\n   * @param {Vector} other The unit vector to project onto.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['projectN'] = Vector.prototype.projectN = function (other) {\n    var amt = this.dot(other);\n    this['x'] = amt * other['x'];\n    this['y'] = amt * other['y'];\n    return this;\n  };\n\n  // Reflect this vector on an arbitrary axis.\n  /**\n   * @param {Vector} axis The vector representing the axis.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reflect'] = Vector.prototype.reflect = function (axis) {\n    var x = this['x'];\n    var y = this['y'];\n    this.project(axis).scale(2);\n    this['x'] -= x;\n    this['y'] -= y;\n    return this;\n  };\n\n  // Reflect this vector on an arbitrary axis (represented by a unit vector). This is\n  // slightly more efficient than `reflect` when dealing with an axis that is a unit vector.\n  /**\n   * @param {Vector} axis The unit vector representing the axis.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reflectN'] = Vector.prototype.reflectN = function (axis) {\n    var x = this['x'];\n    var y = this['y'];\n    this.projectN(axis).scale(2);\n    this['x'] -= x;\n    this['y'] -= y;\n    return this;\n  };\n\n  // Get the dot product of this vector and another.\n  /**\n   * @param {Vector}  other The vector to dot this one against.\n   * @return {number} The dot product.\n   */\n  Vector.prototype['dot'] = Vector.prototype.dot = function (other) {\n    return this['x'] * other['x'] + this['y'] * other['y'];\n  };\n\n  // Get the squared length of this vector.\n  /**\n   * @return {number} The length^2 of this vector.\n   */\n  Vector.prototype['len2'] = Vector.prototype.len2 = function () {\n    return this.dot(this);\n  };\n\n  // Get the length of this vector.\n  /**\n   * @return {number} The length of this vector.\n   */\n  Vector.prototype['len'] = Vector.prototype.len = function () {\n    return Math.sqrt(this.len2());\n  };\n\n  // ## Circle\n  //\n  // Represents a circle with a position and a radius.\n\n  // Create a new circle, optionally passing in a position and/or radius. If no position\n  // is given, the circle will be at `(0,0)`. If no radius is provided, the circle will\n  // have a radius of `0`.\n  /**\n   * @param {Vector=} pos A vector representing the position of the center of the circle\n   * @param {?number=} r The radius of the circle\n   * @constructor\n   */\n  function Circle(pos, r) {\n    this['pos'] = pos || new Vector();\n    this['r'] = r || 0;\n    this['offset'] = new Vector();\n  }\n  SAT['Circle'] = Circle;\n\n  // Compute the axis-aligned bounding box (AABB) of this Circle.\n  //\n  // Note: Returns a _new_ `Box` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Circle.prototype['getAABBAsBox'] = Circle.prototype.getAABBAsBox = function () {\n    var r = this['r'];\n    var corner = this['pos'].clone().add(this['offset']).sub(new Vector(r, r));\n    return new Box(corner, r * 2, r * 2);\n  };\n\n  // Compute the axis-aligned bounding box (AABB) of this Circle.\n  //\n  // Note: Returns a _new_ `Polygon` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Circle.prototype['getAABB'] = Circle.prototype.getAABB = function () {\n    return this.getAABBAsBox().toPolygon();\n  };\n\n  // Set the current offset to apply to the radius.\n  /**\n   * @param {Vector} offset The new offset vector.\n   * @return {Circle} This for chaining.\n   */\n  Circle.prototype['setOffset'] = Circle.prototype.setOffset = function (offset) {\n    this['offset'] = offset;\n    return this;\n  };\n\n  // ## Polygon\n  //\n  // Represents a *convex* polygon with any number of points (specified in counter-clockwise order)\n  //\n  // Note: Do _not_ manually change the `points`, `angle`, or `offset` properties. Use the\n  // provided setters. Otherwise the calculated properties will not be updated correctly.\n  //\n  // `pos` can be changed directly.\n\n  // Create a new polygon, passing in a position vector, and an array of points (represented\n  // by vectors relative to the position vector). If no position is passed in, the position\n  // of the polygon will be `(0,0)`.\n  /**\n   * @param {Vector=} pos A vector representing the origin of the polygon. (all other\n   *   points are relative to this one)\n   * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,\n   *   in counter-clockwise order.\n   * @constructor\n   */\n  function Polygon(pos, points) {\n    this['pos'] = pos || new Vector();\n    this['angle'] = 0;\n    this['offset'] = new Vector();\n    this.setPoints(points || []);\n  }\n  SAT['Polygon'] = Polygon;\n\n  // Set the points of the polygon. Any consecutive duplicate points will be combined.\n  //\n  // Note: The points are counter-clockwise *with respect to the coordinate system*.\n  // If you directly draw the points on a screen that has the origin at the top-left corner\n  // it will _appear_ visually that the points are being specified clockwise. This is just\n  // because of the inversion of the Y-axis when being displayed.\n  /**\n   * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,\n   *   in counter-clockwise order.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setPoints'] = Polygon.prototype.setPoints = function (points) {\n    // Only re-allocate if this is a new polygon or the number of points has changed.\n    var lengthChanged = !this['points'] || this['points'].length !== points.length;\n    if (lengthChanged) {\n      var i;\n      var calcPoints = this['calcPoints'] = [];\n      var edges = this['edges'] = [];\n      var normals = this['normals'] = [];\n      // Allocate the vector arrays for the calculated properties\n      for (i = 0; i < points.length; i++) {\n        // Remove consecutive duplicate points\n        var p1 = points[i];\n        var p2 = i < points.length - 1 ? points[i + 1] : points[0];\n        if (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {\n          points.splice(i, 1);\n          i -= 1;\n          continue;\n        }\n        calcPoints.push(new Vector());\n        edges.push(new Vector());\n        normals.push(new Vector());\n      }\n    }\n    this['points'] = points;\n    this._recalc();\n    return this;\n  };\n\n  // Set the current rotation angle of the polygon.\n  /**\n   * @param {number} angle The current rotation angle (in radians).\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setAngle'] = Polygon.prototype.setAngle = function (angle) {\n    this['angle'] = angle;\n    this._recalc();\n    return this;\n  };\n\n  // Set the current offset to apply to the `points` before applying the `angle` rotation.\n  /**\n   * @param {Vector} offset The new offset vector.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setOffset'] = Polygon.prototype.setOffset = function (offset) {\n    this['offset'] = offset;\n    this._recalc();\n    return this;\n  };\n\n  // Rotates this polygon counter-clockwise around the origin of *its local coordinate system* (i.e. `pos`).\n  //\n  // Note: This changes the **original** points (so any `angle` will be applied on top of this rotation).\n  /**\n   * @param {number} angle The angle to rotate (in radians)\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['rotate'] = Polygon.prototype.rotate = function (angle) {\n    var points = this['points'];\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      points[i].rotate(angle);\n    }\n    this._recalc();\n    return this;\n  };\n\n  // Translates the points of this polygon by a specified amount relative to the origin of *its own coordinate\n  // system* (i.e. `pos`).\n  //\n  // This is most useful to change the \"center point\" of a polygon. If you just want to move the whole polygon, change\n  // the coordinates of `pos`.\n  //\n  // Note: This changes the **original** points (so any `offset` will be applied on top of this translation)\n  /**\n   * @param {number} x The horizontal amount to translate.\n   * @param {number} y The vertical amount to translate.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['translate'] = Polygon.prototype.translate = function (x, y) {\n    var points = this['points'];\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      points[i]['x'] += x;\n      points[i]['y'] += y;\n    }\n    this._recalc();\n    return this;\n  };\n\n  // Computes the calculated collision polygon. Applies the `angle` and `offset` to the original points then recalculates the\n  // edges and normals of the collision polygon.\n  /**\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype._recalc = function () {\n    // Calculated points - this is what is used for underlying collisions and takes into account\n    // the angle/offset set on the polygon.\n    var calcPoints = this['calcPoints'];\n    // The edges here are the direction of the `n`th edge of the polygon, relative to\n    // the `n`th point. If you want to draw a given edge from the edge value, you must\n    // first translate to the position of the starting point.\n    var edges = this['edges'];\n    // The normals here are the direction of the normal for the `n`th edge of the polygon, relative\n    // to the position of the `n`th point. If you want to draw an edge normal, you must first\n    // translate to the position of the starting point.\n    var normals = this['normals'];\n    // Copy the original points array and apply the offset/angle\n    var points = this['points'];\n    var offset = this['offset'];\n    var angle = this['angle'];\n    var len = points.length;\n    var i;\n    for (i = 0; i < len; i++) {\n      var calcPoint = calcPoints[i].copy(points[i]);\n      calcPoint['x'] += offset['x'];\n      calcPoint['y'] += offset['y'];\n      if (angle !== 0) {\n        calcPoint.rotate(angle);\n      }\n    }\n    // Calculate the edges/normals\n    for (i = 0; i < len; i++) {\n      var p1 = calcPoints[i];\n      var p2 = i < len - 1 ? calcPoints[i + 1] : calcPoints[0];\n      var e = edges[i].copy(p2).sub(p1);\n      normals[i].copy(e).perp().normalize();\n    }\n    return this;\n  };\n\n  // Compute the axis-aligned bounding box. Any current state\n  // (translations/rotations) will be applied before constructing the AABB.\n  //\n  // Note: Returns a _new_ `Box` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Polygon.prototype['getAABBAsBox'] = Polygon.prototype.getAABBAsBox = function () {\n    var points = this['calcPoints'];\n    var len = points.length;\n    var xMin = points[0]['x'];\n    var yMin = points[0]['y'];\n    var xMax = points[0]['x'];\n    var yMax = points[0]['y'];\n    for (var i = 1; i < len; i++) {\n      var point = points[i];\n      if (point['x'] < xMin) {\n        xMin = point['x'];\n      } else if (point['x'] > xMax) {\n        xMax = point['x'];\n      }\n      if (point['y'] < yMin) {\n        yMin = point['y'];\n      } else if (point['y'] > yMax) {\n        yMax = point['y'];\n      }\n    }\n    return new Box(this['pos'].clone().add(new Vector(xMin, yMin)), xMax - xMin, yMax - yMin);\n  };\n\n  // Compute the axis-aligned bounding box. Any current state\n  // (translations/rotations) will be applied before constructing the AABB.\n  //\n  // Note: Returns a _new_ `Polygon` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Polygon.prototype['getAABB'] = Polygon.prototype.getAABB = function () {\n    return this.getAABBAsBox().toPolygon();\n  };\n\n  // Compute the centroid (geometric center) of the polygon. Any current state\n  // (translations/rotations) will be applied before computing the centroid.\n  //\n  // See https://en.wikipedia.org/wiki/Centroid#Centroid_of_a_polygon\n  //\n  // Note: Returns a _new_ `Vector` each time you call this.\n  /**\n   * @return {Vector} A Vector that contains the coordinates of the Centroid.\n   */\n  Polygon.prototype['getCentroid'] = Polygon.prototype.getCentroid = function () {\n    var points = this['calcPoints'];\n    var len = points.length;\n    var cx = 0;\n    var cy = 0;\n    var ar = 0;\n    for (var i = 0; i < len; i++) {\n      var p1 = points[i];\n      var p2 = i === len - 1 ? points[0] : points[i + 1]; // Loop around if last point\n      var a = p1['x'] * p2['y'] - p2['x'] * p1['y'];\n      cx += (p1['x'] + p2['x']) * a;\n      cy += (p1['y'] + p2['y']) * a;\n      ar += a;\n    }\n    ar = ar * 3; // we want 1 / 6 the area and we currently have 2*area\n    cx = cx / ar;\n    cy = cy / ar;\n    return new Vector(cx, cy);\n  };\n\n  // ## Box\n  //\n  // Represents an axis-aligned box, with a width and height.\n\n  // Create a new box, with the specified position, width, and height. If no position\n  // is given, the position will be `(0,0)`. If no width or height are given, they will\n  // be set to `0`.\n  /**\n   * @param {Vector=} pos A vector representing the bottom-left of the box (i.e. the smallest x and smallest y value).\n   * @param {?number=} w The width of the box.\n   * @param {?number=} h The height of the box.\n   * @constructor\n   */\n  function Box(pos, w, h) {\n    this['pos'] = pos || new Vector();\n    this['w'] = w || 0;\n    this['h'] = h || 0;\n  }\n  SAT['Box'] = Box;\n\n  // Returns a polygon whose edges are the same as this box.\n  /**\n   * @return {Polygon} A new Polygon that represents this box.\n   */\n  Box.prototype['toPolygon'] = Box.prototype.toPolygon = function () {\n    var pos = this['pos'];\n    var w = this['w'];\n    var h = this['h'];\n    return new Polygon(new Vector(pos['x'], pos['y']), [new Vector(), new Vector(w, 0), new Vector(w, h), new Vector(0, h)]);\n  };\n\n  // ## Response\n  //\n  // An object representing the result of an intersection. Contains:\n  //  - The two objects participating in the intersection\n  //  - The vector representing the minimum change necessary to extract the first object\n  //    from the second one (as well as a unit vector in that direction and the magnitude\n  //    of the overlap)\n  //  - Whether the first object is entirely inside the second, and vice versa.\n  /**\n   * @constructor\n   */\n  function Response() {\n    this['a'] = null;\n    this['b'] = null;\n    this['overlapN'] = new Vector();\n    this['overlapV'] = new Vector();\n    this.clear();\n  }\n  SAT['Response'] = Response;\n\n  // Set some values of the response back to their defaults.  Call this between tests if\n  // you are going to reuse a single Response object for multiple intersection tests (recommented\n  // as it will avoid allcating extra memory)\n  /**\n   * @return {Response} This for chaining\n   */\n  Response.prototype['clear'] = Response.prototype.clear = function () {\n    this['aInB'] = true;\n    this['bInA'] = true;\n    this['overlap'] = Number.MAX_VALUE;\n    return this;\n  };\n\n  // ## Object Pools\n\n  // A pool of `Vector` objects that are used in calculations to avoid\n  // allocating memory.\n  /**\n   * @type {Array<Vector>}\n   */\n  var T_VECTORS = [];\n  for (var i = 0; i < 10; i++) {\n    T_VECTORS.push(new Vector());\n  }\n\n  // A pool of arrays of numbers used in calculations to avoid allocating\n  // memory.\n  /**\n   * @type {Array<Array<number>>}\n   */\n  var T_ARRAYS = [];\n  for (var i = 0; i < 5; i++) {\n    T_ARRAYS.push([]);\n  }\n\n  // Temporary response used for polygon hit detection.\n  /**\n   * @type {Response}\n   */\n  var T_RESPONSE = new Response();\n\n  // Tiny \"point\" polygon used for polygon hit detection.\n  /**\n   * @type {Polygon}\n   */\n  var TEST_POINT = new Box(new Vector(), 0.000001, 0.000001).toPolygon();\n\n  // ## Helper Functions\n\n  // Flattens the specified array of points onto a unit vector axis,\n  // resulting in a one dimensional range of the minimum and\n  // maximum value on that axis.\n  /**\n   * @param {Array<Vector>} points The points to flatten.\n   * @param {Vector} normal The unit vector axis to flatten on.\n   * @param {Array<number>} result An array.  After calling this function,\n   *   result[0] will be the minimum value,\n   *   result[1] will be the maximum value.\n   */\n  function flattenPointsOn(points, normal, result) {\n    var min = Number.MAX_VALUE;\n    var max = -Number.MAX_VALUE;\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      // The magnitude of the projection of the point onto the normal\n      var dot = points[i].dot(normal);\n      if (dot < min) {\n        min = dot;\n      }\n      if (dot > max) {\n        max = dot;\n      }\n    }\n    result[0] = min;\n    result[1] = max;\n  }\n\n  // Check whether two convex polygons are separated by the specified\n  // axis (must be a unit vector).\n  /**\n   * @param {Vector} aPos The position of the first polygon.\n   * @param {Vector} bPos The position of the second polygon.\n   * @param {Array<Vector>} aPoints The points in the first polygon.\n   * @param {Array<Vector>} bPoints The points in the second polygon.\n   * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons\n   *   will be projected onto this axis.\n   * @param {Response=} response A Response object (optional) which will be populated\n   *   if the axis is not a separating axis.\n   * @return {boolean} true if it is a separating axis, false otherwise.  If false,\n   *   and a response is passed in, information about how much overlap and\n   *   the direction of the overlap will be populated.\n   */\n  function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {\n    var rangeA = T_ARRAYS.pop();\n    var rangeB = T_ARRAYS.pop();\n    // The magnitude of the offset between the two polygons\n    var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);\n    var projectedOffset = offsetV.dot(axis);\n    // Project the polygons onto the axis.\n    flattenPointsOn(aPoints, axis, rangeA);\n    flattenPointsOn(bPoints, axis, rangeB);\n    // Move B's range to its position relative to A.\n    rangeB[0] += projectedOffset;\n    rangeB[1] += projectedOffset;\n    // Check if there is a gap. If there is, this is a separating axis and we can stop\n    if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {\n      T_VECTORS.push(offsetV);\n      T_ARRAYS.push(rangeA);\n      T_ARRAYS.push(rangeB);\n      return true;\n    }\n    // This is not a separating axis. If we're calculating a response, calculate the overlap.\n    if (response) {\n      var overlap = 0;\n      // A starts further left than B\n      if (rangeA[0] < rangeB[0]) {\n        response['aInB'] = false;\n        // A ends before B does. We have to pull A out of B\n        if (rangeA[1] < rangeB[1]) {\n          overlap = rangeA[1] - rangeB[0];\n          response['bInA'] = false;\n          // B is fully inside A.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n        // B starts further left than A\n      } else {\n        response['bInA'] = false;\n        // B ends before A ends. We have to push A out of B\n        if (rangeA[1] > rangeB[1]) {\n          overlap = rangeA[0] - rangeB[1];\n          response['aInB'] = false;\n          // A is fully inside B.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n      }\n      // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.\n      var absOverlap = Math.abs(overlap);\n      if (absOverlap < response['overlap']) {\n        response['overlap'] = absOverlap;\n        response['overlapN'].copy(axis);\n        if (overlap < 0) {\n          response['overlapN'].reverse();\n        }\n      }\n    }\n    T_VECTORS.push(offsetV);\n    T_ARRAYS.push(rangeA);\n    T_ARRAYS.push(rangeB);\n    return false;\n  }\n  SAT['isSeparatingAxis'] = isSeparatingAxis;\n\n  // Calculates which Voronoi region a point is on a line segment.\n  // It is assumed that both the line and the point are relative to `(0,0)`\n  //\n  //            |       (0)      |\n  //     (-1)  [S]--------------[E]  (1)\n  //            |       (0)      |\n  /**\n   * @param {Vector} line The line segment.\n   * @param {Vector} point The point.\n   * @return  {number} LEFT_VORONOI_REGION (-1) if it is the left region,\n   *          MIDDLE_VORONOI_REGION (0) if it is the middle region,\n   *          RIGHT_VORONOI_REGION (1) if it is the right region.\n   */\n  function voronoiRegion(line, point) {\n    var len2 = line.len2();\n    var dp = point.dot(line);\n    // If the point is beyond the start of the line, it is in the\n    // left voronoi region.\n    if (dp < 0) {\n      return LEFT_VORONOI_REGION;\n    }\n    // If the point is beyond the end of the line, it is in the\n    // right voronoi region.\n    else if (dp > len2) {\n      return RIGHT_VORONOI_REGION;\n    }\n    // Otherwise, it's in the middle one.\n    else {\n      return MIDDLE_VORONOI_REGION;\n    }\n  }\n  // Constants for Voronoi regions\n  /**\n   * @const\n   */\n  var LEFT_VORONOI_REGION = -1;\n  /**\n   * @const\n   */\n  var MIDDLE_VORONOI_REGION = 0;\n  /**\n   * @const\n   */\n  var RIGHT_VORONOI_REGION = 1;\n\n  // ## Collision Tests\n\n  // Check if a point is inside a circle.\n  /**\n   * @param {Vector} p The point to test.\n   * @param {Circle} c The circle to test.\n   * @return {boolean} true if the point is inside the circle, false if it is not.\n   */\n  function pointInCircle(p, c) {\n    var differenceV = T_VECTORS.pop().copy(p).sub(c['pos']).sub(c['offset']);\n    var radiusSq = c['r'] * c['r'];\n    var distanceSq = differenceV.len2();\n    T_VECTORS.push(differenceV);\n    // If the distance between is smaller than the radius then the point is inside the circle.\n    return distanceSq <= radiusSq;\n  }\n  SAT['pointInCircle'] = pointInCircle;\n\n  // Check if a point is inside a convex polygon.\n  /**\n   * @param {Vector} p The point to test.\n   * @param {Polygon} poly The polygon to test.\n   * @return {boolean} true if the point is inside the polygon, false if it is not.\n   */\n  function pointInPolygon(p, poly) {\n    TEST_POINT['pos'].copy(p);\n    T_RESPONSE.clear();\n    var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);\n    if (result) {\n      result = T_RESPONSE['aInB'];\n    }\n    return result;\n  }\n  SAT['pointInPolygon'] = pointInPolygon;\n\n  // Check if two circles collide.\n  /**\n   * @param {Circle} a The first circle.\n   * @param {Circle} b The second circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   the circles intersect.\n   * @return {boolean} true if the circles intersect, false if they don't.\n   */\n  function testCircleCircle(a, b, response) {\n    // Check if the distance between the centers of the two\n    // circles is greater than their combined radius.\n    var differenceV = T_VECTORS.pop().copy(b['pos']).add(b['offset']).sub(a['pos']).sub(a['offset']);\n    var totalRadius = a['r'] + b['r'];\n    var totalRadiusSq = totalRadius * totalRadius;\n    var distanceSq = differenceV.len2();\n    // If the distance is bigger than the combined radius, they don't intersect.\n    if (distanceSq > totalRadiusSq) {\n      T_VECTORS.push(differenceV);\n      return false;\n    }\n    // They intersect.  If we're calculating a response, calculate the overlap.\n    if (response) {\n      var dist = Math.sqrt(distanceSq);\n      response['a'] = a;\n      response['b'] = b;\n      response['overlap'] = totalRadius - dist;\n      response['overlapN'].copy(differenceV.normalize());\n      response['overlapV'].copy(differenceV).scale(response['overlap']);\n      response['aInB'] = a['r'] <= b['r'] && dist <= b['r'] - a['r'];\n      response['bInA'] = b['r'] <= a['r'] && dist <= a['r'] - b['r'];\n    }\n    T_VECTORS.push(differenceV);\n    return true;\n  }\n  SAT['testCircleCircle'] = testCircleCircle;\n\n  // Check if a polygon and a circle collide.\n  /**\n   * @param {Polygon} polygon The polygon.\n   * @param {Circle} circle The circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonCircle(polygon, circle, response) {\n    // Get the position of the circle relative to the polygon.\n    var circlePos = T_VECTORS.pop().copy(circle['pos']).add(circle['offset']).sub(polygon['pos']);\n    var radius = circle['r'];\n    var radius2 = radius * radius;\n    var points = polygon['calcPoints'];\n    var len = points.length;\n    var edge = T_VECTORS.pop();\n    var point = T_VECTORS.pop();\n\n    // For each edge in the polygon:\n    for (var i = 0; i < len; i++) {\n      var next = i === len - 1 ? 0 : i + 1;\n      var prev = i === 0 ? len - 1 : i - 1;\n      var overlap = 0;\n      var overlapN = null;\n\n      // Get the edge.\n      edge.copy(polygon['edges'][i]);\n      // Calculate the center of the circle relative to the starting point of the edge.\n      point.copy(circlePos).sub(points[i]);\n\n      // If the distance between the center of the circle and the point\n      // is bigger than the radius, the polygon is definitely not fully in\n      // the circle.\n      if (response && point.len2() > radius2) {\n        response['aInB'] = false;\n      }\n\n      // Calculate which Voronoi region the center of the circle is in.\n      var region = voronoiRegion(edge, point);\n      // If it's the left region:\n      if (region === LEFT_VORONOI_REGION) {\n        // We need to make sure we're in the RIGHT_VORONOI_REGION of the previous edge.\n        edge.copy(polygon['edges'][prev]);\n        // Calculate the center of the circle relative the starting point of the previous edge\n        var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);\n        region = voronoiRegion(edge, point2);\n        if (region === RIGHT_VORONOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos);\n            T_VECTORS.push(edge);\n            T_VECTORS.push(point);\n            T_VECTORS.push(point2);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n        T_VECTORS.push(point2);\n        // If it's the right region:\n      } else if (region === RIGHT_VORONOI_REGION) {\n        // We need to make sure we're in the left region on the next edge\n        edge.copy(polygon['edges'][next]);\n        // Calculate the center of the circle relative to the starting point of the next edge.\n        point.copy(circlePos).sub(points[next]);\n        region = voronoiRegion(edge, point);\n        if (region === LEFT_VORONOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos);\n            T_VECTORS.push(edge);\n            T_VECTORS.push(point);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n        // Otherwise, it's the middle region:\n      } else {\n        // Need to check if the circle is intersecting the edge,\n        // Change the edge into its \"edge normal\".\n        var normal = edge.perp().normalize();\n        // Find the perpendicular distance between the center of the\n        // circle and the edge.\n        var dist = point.dot(normal);\n        var distAbs = Math.abs(dist);\n        // If the circle is on the outside of the edge, there is no intersection.\n        if (dist > 0 && distAbs > radius) {\n          // No intersection\n          T_VECTORS.push(circlePos);\n          T_VECTORS.push(normal);\n          T_VECTORS.push(point);\n          return false;\n        } else if (response) {\n          // It intersects, calculate the overlap.\n          overlapN = normal;\n          overlap = radius - dist;\n          // If the center of the circle is on the outside of the edge, or part of the\n          // circle is on the outside, the circle is not fully inside the polygon.\n          if (dist >= 0 || overlap < 2 * radius) {\n            response['bInA'] = false;\n          }\n        }\n      }\n\n      // If this is the smallest overlap we've seen, keep it.\n      // (overlapN may be null if the circle was in the wrong Voronoi region).\n      if (overlapN && response && Math.abs(overlap) < Math.abs(response['overlap'])) {\n        response['overlap'] = overlap;\n        response['overlapN'].copy(overlapN);\n      }\n    }\n\n    // Calculate the final overlap vector - based on the smallest overlap.\n    if (response) {\n      response['a'] = polygon;\n      response['b'] = circle;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    T_VECTORS.push(circlePos);\n    T_VECTORS.push(edge);\n    T_VECTORS.push(point);\n    return true;\n  }\n  SAT['testPolygonCircle'] = testPolygonCircle;\n\n  // Check if a circle and a polygon collide.\n  //\n  // **NOTE:** This is slightly less efficient than polygonCircle as it just\n  // runs polygonCircle and reverses everything at the end.\n  /**\n   * @param {Circle} circle The circle.\n   * @param {Polygon} polygon The polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testCirclePolygon(circle, polygon, response) {\n    // Test the polygon against the circle.\n    var result = testPolygonCircle(polygon, circle, response);\n    if (result && response) {\n      // Swap A and B in the response.\n      var a = response['a'];\n      var aInB = response['aInB'];\n      response['overlapN'].reverse();\n      response['overlapV'].reverse();\n      response['a'] = response['b'];\n      response['b'] = a;\n      response['aInB'] = response['bInA'];\n      response['bInA'] = aInB;\n    }\n    return result;\n  }\n  SAT['testCirclePolygon'] = testCirclePolygon;\n\n  // Checks whether polygons collide.\n  /**\n   * @param {Polygon} a The first polygon.\n   * @param {Polygon} b The second polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonPolygon(a, b, response) {\n    var aPoints = a['calcPoints'];\n    var aLen = aPoints.length;\n    var bPoints = b['calcPoints'];\n    var bLen = bPoints.length;\n    // If any of the edge normals of A is a separating axis, no intersection.\n    for (var i = 0; i < aLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, a['normals'][i], response)) {\n        return false;\n      }\n    }\n    // If any of the edge normals of B is a separating axis, no intersection.\n    for (var i = 0; i < bLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, b['normals'][i], response)) {\n        return false;\n      }\n    }\n    // Since none of the edge normals of A or B are a separating axis, there is an intersection\n    // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the\n    // final overlap vector.\n    if (response) {\n      response['a'] = a;\n      response['b'] = b;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    return true;\n  }\n  SAT['testPolygonPolygon'] = testPolygonPolygon;\n  return SAT;\n});","map":{"version":3,"names":["root","factory","define","exports","module","SAT","Vector","x","y","prototype","copy","other","clone","perp","rotate","angle","Math","cos","sin","reverse","normalize","d","len","add","sub","scale","project","amt","dot","len2","projectN","reflect","axis","reflectN","sqrt","Circle","pos","r","getAABBAsBox","corner","Box","getAABB","toPolygon","setOffset","offset","Polygon","points","setPoints","lengthChanged","length","i","calcPoints","edges","normals","p1","p2","splice","push","_recalc","setAngle","translate","calcPoint","e","xMin","yMin","xMax","yMax","point","getCentroid","cx","cy","ar","a","w","h","Response","clear","Number","MAX_VALUE","T_VECTORS","T_ARRAYS","T_RESPONSE","TEST_POINT","flattenPointsOn","normal","result","min","max","isSeparatingAxis","aPos","bPos","aPoints","bPoints","response","rangeA","pop","rangeB","offsetV","projectedOffset","overlap","option1","option2","absOverlap","abs","voronoiRegion","line","dp","LEFT_VORONOI_REGION","RIGHT_VORONOI_REGION","MIDDLE_VORONOI_REGION","pointInCircle","p","c","differenceV","radiusSq","distanceSq","pointInPolygon","poly","testPolygonPolygon","testCircleCircle","b","totalRadius","totalRadiusSq","dist","testPolygonCircle","polygon","circle","circlePos","radius","radius2","edge","next","prev","overlapN","region","point2","distAbs","testCirclePolygon","aInB","aLen","bLen"],"sources":["C:/Users/gaspa/OneDrive/Documents/MMI 2/S4/React/SpinningWheel/spin-wheel/node_modules/sat/SAT.js"],"sourcesContent":["// Version 0.9.0 - Copyright 2012 - 2021 -  Jim Riecken <jimr@jimr.ca>\n//\n// Released under the MIT License - https://github.com/jriecken/sat-js\n//\n// A simple library for determining intersections of circles and\n// polygons using the Separating Axis Theorem.\n/** @preserve SAT.js - Version 0.9.0 - Copyright 2012 - 2021 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */\n\n/*global define: false, module: false*/\n/*jshint shadow:true, sub:true, forin:true, noarg:true, noempty:true,\n  eqeqeq:true, bitwise:true, strict:true, undef:true,\n  curly:true, browser:true */\n\n// Create a UMD wrapper for SAT. Works in:\n//\n//  - Plain browser via global SAT variable\n//  - AMD loader (like require.js)\n//  - Node.js\n//\n// The quoted properties all over the place are used so that the Closure Compiler\n// does not mangle the exposed API in advanced mode.\n/**\n * @param {*} root - The global scope\n * @param {Function} factory - Factory that creates SAT module\n */\n(function (root, factory) {\n  \"use strict\";\n  if (typeof define === 'function' && define['amd']) {\n    define(factory);\n  } else if (typeof exports === 'object') {\n    module['exports'] = factory();\n  } else {\n    root['SAT'] = factory();\n  }\n}(this, function () {\n  \"use strict\";\n\n  var SAT = {};\n\n  //\n  // ## Vector\n  //\n  // Represents a vector in two dimensions with `x` and `y` properties.\n\n\n  // Create a new Vector, optionally passing in the `x` and `y` coordinates. If\n  // a coordinate is not specified, it will be set to `0`\n  /**\n   * @param {?number=} x The x position.\n   * @param {?number=} y The y position.\n   * @constructor\n   */\n  function Vector(x, y) {\n    this['x'] = x || 0;\n    this['y'] = y || 0;\n  }\n  SAT['Vector'] = Vector;\n  // Alias `Vector` as `V`\n  SAT['V'] = Vector;\n\n\n  // Copy the values of another Vector into this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['copy'] = Vector.prototype.copy = function (other) {\n    this['x'] = other['x'];\n    this['y'] = other['y'];\n    return this;\n  };\n\n  // Create a new vector with the same coordinates as this on.\n  /**\n   * @return {Vector} The new cloned vector\n   */\n  Vector.prototype['clone'] = Vector.prototype.clone = function () {\n    return new Vector(this['x'], this['y']);\n  };\n\n  // Change this vector to be perpendicular to what it was before. (Effectively\n  // roatates it 90 degrees in a clockwise direction)\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['perp'] = Vector.prototype.perp = function () {\n    var x = this['x'];\n    this['x'] = this['y'];\n    this['y'] = -x;\n    return this;\n  };\n\n  // Rotate this vector (counter-clockwise) by the specified angle (in radians).\n  /**\n   * @param {number} angle The angle to rotate (in radians)\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['rotate'] = Vector.prototype.rotate = function (angle) {\n    var x = this['x'];\n    var y = this['y'];\n    this['x'] = x * Math.cos(angle) - y * Math.sin(angle);\n    this['y'] = x * Math.sin(angle) + y * Math.cos(angle);\n    return this;\n  };\n\n  // Reverse this vector.\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reverse'] = Vector.prototype.reverse = function () {\n    this['x'] = -this['x'];\n    this['y'] = -this['y'];\n    return this;\n  };\n\n\n  // Normalize this vector.  (make it have length of `1`)\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['normalize'] = Vector.prototype.normalize = function () {\n    var d = this.len();\n    if (d > 0) {\n      this['x'] = this['x'] / d;\n      this['y'] = this['y'] / d;\n    }\n    return this;\n  };\n\n  // Add another vector to this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['add'] = Vector.prototype.add = function (other) {\n    this['x'] += other['x'];\n    this['y'] += other['y'];\n    return this;\n  };\n\n  // Subtract another vector from this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaiing.\n   */\n  Vector.prototype['sub'] = Vector.prototype.sub = function (other) {\n    this['x'] -= other['x'];\n    this['y'] -= other['y'];\n    return this;\n  };\n\n  // Scale this vector. An independent scaling factor can be provided\n  // for each axis, or a single scaling factor that will scale both `x` and `y`.\n  /**\n   * @param {number} x The scaling factor in the x direction.\n   * @param {?number=} y The scaling factor in the y direction.  If this\n   *   is not specified, the x scaling factor will be used.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['scale'] = Vector.prototype.scale = function (x, y) {\n    this['x'] *= x;\n    this['y'] *= typeof y != 'undefined' ? y : x;\n    return this;\n  };\n\n  // Project this vector on to another vector.\n  /**\n   * @param {Vector} other The vector to project onto.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['project'] = Vector.prototype.project = function (other) {\n    var amt = this.dot(other) / other.len2();\n    this['x'] = amt * other['x'];\n    this['y'] = amt * other['y'];\n    return this;\n  };\n\n  // Project this vector onto a vector of unit length. This is slightly more efficient\n  // than `project` when dealing with unit vectors.\n  /**\n   * @param {Vector} other The unit vector to project onto.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['projectN'] = Vector.prototype.projectN = function (other) {\n    var amt = this.dot(other);\n    this['x'] = amt * other['x'];\n    this['y'] = amt * other['y'];\n    return this;\n  };\n\n  // Reflect this vector on an arbitrary axis.\n  /**\n   * @param {Vector} axis The vector representing the axis.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reflect'] = Vector.prototype.reflect = function (axis) {\n    var x = this['x'];\n    var y = this['y'];\n    this.project(axis).scale(2);\n    this['x'] -= x;\n    this['y'] -= y;\n    return this;\n  };\n\n  // Reflect this vector on an arbitrary axis (represented by a unit vector). This is\n  // slightly more efficient than `reflect` when dealing with an axis that is a unit vector.\n  /**\n   * @param {Vector} axis The unit vector representing the axis.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reflectN'] = Vector.prototype.reflectN = function (axis) {\n    var x = this['x'];\n    var y = this['y'];\n    this.projectN(axis).scale(2);\n    this['x'] -= x;\n    this['y'] -= y;\n    return this;\n  };\n\n  // Get the dot product of this vector and another.\n  /**\n   * @param {Vector}  other The vector to dot this one against.\n   * @return {number} The dot product.\n   */\n  Vector.prototype['dot'] = Vector.prototype.dot = function (other) {\n    return this['x'] * other['x'] + this['y'] * other['y'];\n  };\n\n  // Get the squared length of this vector.\n  /**\n   * @return {number} The length^2 of this vector.\n   */\n  Vector.prototype['len2'] = Vector.prototype.len2 = function () {\n    return this.dot(this);\n  };\n\n  // Get the length of this vector.\n  /**\n   * @return {number} The length of this vector.\n   */\n  Vector.prototype['len'] = Vector.prototype.len = function () {\n    return Math.sqrt(this.len2());\n  };\n\n  // ## Circle\n  //\n  // Represents a circle with a position and a radius.\n\n  // Create a new circle, optionally passing in a position and/or radius. If no position\n  // is given, the circle will be at `(0,0)`. If no radius is provided, the circle will\n  // have a radius of `0`.\n  /**\n   * @param {Vector=} pos A vector representing the position of the center of the circle\n   * @param {?number=} r The radius of the circle\n   * @constructor\n   */\n  function Circle(pos, r) {\n    this['pos'] = pos || new Vector();\n    this['r'] = r || 0;\n    this['offset'] = new Vector();\n  }\n  SAT['Circle'] = Circle;\n\n  // Compute the axis-aligned bounding box (AABB) of this Circle.\n  //\n  // Note: Returns a _new_ `Box` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Circle.prototype['getAABBAsBox'] = Circle.prototype.getAABBAsBox = function () {\n    var r = this['r'];\n    var corner = this['pos'].clone().add(this['offset']).sub(new Vector(r, r));\n    return new Box(corner, r * 2, r * 2);\n  };\n\n  // Compute the axis-aligned bounding box (AABB) of this Circle.\n  //\n  // Note: Returns a _new_ `Polygon` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Circle.prototype['getAABB'] = Circle.prototype.getAABB = function () {\n    return this.getAABBAsBox().toPolygon();\n  };\n\n  // Set the current offset to apply to the radius.\n  /**\n   * @param {Vector} offset The new offset vector.\n   * @return {Circle} This for chaining.\n   */\n  Circle.prototype['setOffset'] = Circle.prototype.setOffset = function (offset) {\n    this['offset'] = offset;\n    return this;\n  };\n\n  // ## Polygon\n  //\n  // Represents a *convex* polygon with any number of points (specified in counter-clockwise order)\n  //\n  // Note: Do _not_ manually change the `points`, `angle`, or `offset` properties. Use the\n  // provided setters. Otherwise the calculated properties will not be updated correctly.\n  //\n  // `pos` can be changed directly.\n\n  // Create a new polygon, passing in a position vector, and an array of points (represented\n  // by vectors relative to the position vector). If no position is passed in, the position\n  // of the polygon will be `(0,0)`.\n  /**\n   * @param {Vector=} pos A vector representing the origin of the polygon. (all other\n   *   points are relative to this one)\n   * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,\n   *   in counter-clockwise order.\n   * @constructor\n   */\n  function Polygon(pos, points) {\n    this['pos'] = pos || new Vector();\n    this['angle'] = 0;\n    this['offset'] = new Vector();\n    this.setPoints(points || []);\n  }\n  SAT['Polygon'] = Polygon;\n\n  // Set the points of the polygon. Any consecutive duplicate points will be combined.\n  //\n  // Note: The points are counter-clockwise *with respect to the coordinate system*.\n  // If you directly draw the points on a screen that has the origin at the top-left corner\n  // it will _appear_ visually that the points are being specified clockwise. This is just\n  // because of the inversion of the Y-axis when being displayed.\n  /**\n   * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,\n   *   in counter-clockwise order.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setPoints'] = Polygon.prototype.setPoints = function (points) {\n    // Only re-allocate if this is a new polygon or the number of points has changed.\n    var lengthChanged = !this['points'] || this['points'].length !== points.length;\n    if (lengthChanged) {\n      var i;\n      var calcPoints = this['calcPoints'] = [];\n      var edges = this['edges'] = [];\n      var normals = this['normals'] = [];\n      // Allocate the vector arrays for the calculated properties\n      for (i = 0; i < points.length; i++) {\n        // Remove consecutive duplicate points\n        var p1 = points[i];\n        var p2 = i < points.length - 1 ? points[i + 1] : points[0];\n        if (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {\n          points.splice(i, 1);\n          i -= 1;\n          continue;\n        }\n        calcPoints.push(new Vector());\n        edges.push(new Vector());\n        normals.push(new Vector());\n      }\n    }\n    this['points'] = points;\n    this._recalc();\n    return this;\n  };\n\n  // Set the current rotation angle of the polygon.\n  /**\n   * @param {number} angle The current rotation angle (in radians).\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setAngle'] = Polygon.prototype.setAngle = function (angle) {\n    this['angle'] = angle;\n    this._recalc();\n    return this;\n  };\n\n  // Set the current offset to apply to the `points` before applying the `angle` rotation.\n  /**\n   * @param {Vector} offset The new offset vector.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setOffset'] = Polygon.prototype.setOffset = function (offset) {\n    this['offset'] = offset;\n    this._recalc();\n    return this;\n  };\n\n  // Rotates this polygon counter-clockwise around the origin of *its local coordinate system* (i.e. `pos`).\n  //\n  // Note: This changes the **original** points (so any `angle` will be applied on top of this rotation).\n  /**\n   * @param {number} angle The angle to rotate (in radians)\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['rotate'] = Polygon.prototype.rotate = function (angle) {\n    var points = this['points'];\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      points[i].rotate(angle);\n    }\n    this._recalc();\n    return this;\n  };\n\n  // Translates the points of this polygon by a specified amount relative to the origin of *its own coordinate\n  // system* (i.e. `pos`).\n  //\n  // This is most useful to change the \"center point\" of a polygon. If you just want to move the whole polygon, change\n  // the coordinates of `pos`.\n  //\n  // Note: This changes the **original** points (so any `offset` will be applied on top of this translation)\n  /**\n   * @param {number} x The horizontal amount to translate.\n   * @param {number} y The vertical amount to translate.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['translate'] = Polygon.prototype.translate = function (x, y) {\n    var points = this['points'];\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      points[i]['x'] += x;\n      points[i]['y'] += y;\n    }\n    this._recalc();\n    return this;\n  };\n\n\n  // Computes the calculated collision polygon. Applies the `angle` and `offset` to the original points then recalculates the\n  // edges and normals of the collision polygon.\n  /**\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype._recalc = function () {\n    // Calculated points - this is what is used for underlying collisions and takes into account\n    // the angle/offset set on the polygon.\n    var calcPoints = this['calcPoints'];\n    // The edges here are the direction of the `n`th edge of the polygon, relative to\n    // the `n`th point. If you want to draw a given edge from the edge value, you must\n    // first translate to the position of the starting point.\n    var edges = this['edges'];\n    // The normals here are the direction of the normal for the `n`th edge of the polygon, relative\n    // to the position of the `n`th point. If you want to draw an edge normal, you must first\n    // translate to the position of the starting point.\n    var normals = this['normals'];\n    // Copy the original points array and apply the offset/angle\n    var points = this['points'];\n    var offset = this['offset'];\n    var angle = this['angle'];\n    var len = points.length;\n    var i;\n    for (i = 0; i < len; i++) {\n      var calcPoint = calcPoints[i].copy(points[i]);\n      calcPoint['x'] += offset['x'];\n      calcPoint['y'] += offset['y'];\n      if (angle !== 0) {\n        calcPoint.rotate(angle);\n      }\n    }\n    // Calculate the edges/normals\n    for (i = 0; i < len; i++) {\n      var p1 = calcPoints[i];\n      var p2 = i < len - 1 ? calcPoints[i + 1] : calcPoints[0];\n      var e = edges[i].copy(p2).sub(p1);\n      normals[i].copy(e).perp().normalize();\n    }\n    return this;\n  };\n\n\n  // Compute the axis-aligned bounding box. Any current state\n  // (translations/rotations) will be applied before constructing the AABB.\n  //\n  // Note: Returns a _new_ `Box` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Polygon.prototype['getAABBAsBox'] = Polygon.prototype.getAABBAsBox = function () {\n    var points = this['calcPoints'];\n    var len = points.length;\n    var xMin = points[0]['x'];\n    var yMin = points[0]['y'];\n    var xMax = points[0]['x'];\n    var yMax = points[0]['y'];\n    for (var i = 1; i < len; i++) {\n      var point = points[i];\n      if (point['x'] < xMin) {\n        xMin = point['x'];\n      }\n      else if (point['x'] > xMax) {\n        xMax = point['x'];\n      }\n      if (point['y'] < yMin) {\n        yMin = point['y'];\n      }\n      else if (point['y'] > yMax) {\n        yMax = point['y'];\n      }\n    }\n    return new Box(this['pos'].clone().add(new Vector(xMin, yMin)), xMax - xMin, yMax - yMin);\n  };\n\n\n  // Compute the axis-aligned bounding box. Any current state\n  // (translations/rotations) will be applied before constructing the AABB.\n  //\n  // Note: Returns a _new_ `Polygon` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Polygon.prototype['getAABB'] = Polygon.prototype.getAABB = function () {\n    return this.getAABBAsBox().toPolygon();\n  };\n\n  // Compute the centroid (geometric center) of the polygon. Any current state\n  // (translations/rotations) will be applied before computing the centroid.\n  //\n  // See https://en.wikipedia.org/wiki/Centroid#Centroid_of_a_polygon\n  //\n  // Note: Returns a _new_ `Vector` each time you call this.\n  /**\n   * @return {Vector} A Vector that contains the coordinates of the Centroid.\n   */\n  Polygon.prototype['getCentroid'] = Polygon.prototype.getCentroid = function () {\n    var points = this['calcPoints'];\n    var len = points.length;\n    var cx = 0;\n    var cy = 0;\n    var ar = 0;\n    for (var i = 0; i < len; i++) {\n      var p1 = points[i];\n      var p2 = i === len - 1 ? points[0] : points[i + 1]; // Loop around if last point\n      var a = p1['x'] * p2['y'] - p2['x'] * p1['y'];\n      cx += (p1['x'] + p2['x']) * a;\n      cy += (p1['y'] + p2['y']) * a;\n      ar += a;\n    }\n    ar = ar * 3; // we want 1 / 6 the area and we currently have 2*area\n    cx = cx / ar;\n    cy = cy / ar;\n    return new Vector(cx, cy);\n  };\n\n\n  // ## Box\n  //\n  // Represents an axis-aligned box, with a width and height.\n\n\n  // Create a new box, with the specified position, width, and height. If no position\n  // is given, the position will be `(0,0)`. If no width or height are given, they will\n  // be set to `0`.\n  /**\n   * @param {Vector=} pos A vector representing the bottom-left of the box (i.e. the smallest x and smallest y value).\n   * @param {?number=} w The width of the box.\n   * @param {?number=} h The height of the box.\n   * @constructor\n   */\n  function Box(pos, w, h) {\n    this['pos'] = pos || new Vector();\n    this['w'] = w || 0;\n    this['h'] = h || 0;\n  }\n  SAT['Box'] = Box;\n\n  // Returns a polygon whose edges are the same as this box.\n  /**\n   * @return {Polygon} A new Polygon that represents this box.\n   */\n  Box.prototype['toPolygon'] = Box.prototype.toPolygon = function () {\n    var pos = this['pos'];\n    var w = this['w'];\n    var h = this['h'];\n    return new Polygon(new Vector(pos['x'], pos['y']), [\n      new Vector(), new Vector(w, 0),\n      new Vector(w, h), new Vector(0, h)\n    ]);\n  };\n\n  // ## Response\n  //\n  // An object representing the result of an intersection. Contains:\n  //  - The two objects participating in the intersection\n  //  - The vector representing the minimum change necessary to extract the first object\n  //    from the second one (as well as a unit vector in that direction and the magnitude\n  //    of the overlap)\n  //  - Whether the first object is entirely inside the second, and vice versa.\n  /**\n   * @constructor\n   */\n  function Response() {\n    this['a'] = null;\n    this['b'] = null;\n    this['overlapN'] = new Vector();\n    this['overlapV'] = new Vector();\n    this.clear();\n  }\n  SAT['Response'] = Response;\n\n  // Set some values of the response back to their defaults.  Call this between tests if\n  // you are going to reuse a single Response object for multiple intersection tests (recommented\n  // as it will avoid allcating extra memory)\n  /**\n   * @return {Response} This for chaining\n   */\n  Response.prototype['clear'] = Response.prototype.clear = function () {\n    this['aInB'] = true;\n    this['bInA'] = true;\n    this['overlap'] = Number.MAX_VALUE;\n    return this;\n  };\n\n  // ## Object Pools\n\n  // A pool of `Vector` objects that are used in calculations to avoid\n  // allocating memory.\n  /**\n   * @type {Array<Vector>}\n   */\n  var T_VECTORS = [];\n  for (var i = 0; i < 10; i++) { T_VECTORS.push(new Vector()); }\n\n  // A pool of arrays of numbers used in calculations to avoid allocating\n  // memory.\n  /**\n   * @type {Array<Array<number>>}\n   */\n  var T_ARRAYS = [];\n  for (var i = 0; i < 5; i++) { T_ARRAYS.push([]); }\n\n  // Temporary response used for polygon hit detection.\n  /**\n   * @type {Response}\n   */\n  var T_RESPONSE = new Response();\n\n  // Tiny \"point\" polygon used for polygon hit detection.\n  /**\n   * @type {Polygon}\n   */\n  var TEST_POINT = new Box(new Vector(), 0.000001, 0.000001).toPolygon();\n\n  // ## Helper Functions\n\n  // Flattens the specified array of points onto a unit vector axis,\n  // resulting in a one dimensional range of the minimum and\n  // maximum value on that axis.\n  /**\n   * @param {Array<Vector>} points The points to flatten.\n   * @param {Vector} normal The unit vector axis to flatten on.\n   * @param {Array<number>} result An array.  After calling this function,\n   *   result[0] will be the minimum value,\n   *   result[1] will be the maximum value.\n   */\n  function flattenPointsOn(points, normal, result) {\n    var min = Number.MAX_VALUE;\n    var max = -Number.MAX_VALUE;\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      // The magnitude of the projection of the point onto the normal\n      var dot = points[i].dot(normal);\n      if (dot < min) { min = dot; }\n      if (dot > max) { max = dot; }\n    }\n    result[0] = min; result[1] = max;\n  }\n\n  // Check whether two convex polygons are separated by the specified\n  // axis (must be a unit vector).\n  /**\n   * @param {Vector} aPos The position of the first polygon.\n   * @param {Vector} bPos The position of the second polygon.\n   * @param {Array<Vector>} aPoints The points in the first polygon.\n   * @param {Array<Vector>} bPoints The points in the second polygon.\n   * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons\n   *   will be projected onto this axis.\n   * @param {Response=} response A Response object (optional) which will be populated\n   *   if the axis is not a separating axis.\n   * @return {boolean} true if it is a separating axis, false otherwise.  If false,\n   *   and a response is passed in, information about how much overlap and\n   *   the direction of the overlap will be populated.\n   */\n  function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {\n    var rangeA = T_ARRAYS.pop();\n    var rangeB = T_ARRAYS.pop();\n    // The magnitude of the offset between the two polygons\n    var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);\n    var projectedOffset = offsetV.dot(axis);\n    // Project the polygons onto the axis.\n    flattenPointsOn(aPoints, axis, rangeA);\n    flattenPointsOn(bPoints, axis, rangeB);\n    // Move B's range to its position relative to A.\n    rangeB[0] += projectedOffset;\n    rangeB[1] += projectedOffset;\n    // Check if there is a gap. If there is, this is a separating axis and we can stop\n    if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {\n      T_VECTORS.push(offsetV);\n      T_ARRAYS.push(rangeA);\n      T_ARRAYS.push(rangeB);\n      return true;\n    }\n    // This is not a separating axis. If we're calculating a response, calculate the overlap.\n    if (response) {\n      var overlap = 0;\n      // A starts further left than B\n      if (rangeA[0] < rangeB[0]) {\n        response['aInB'] = false;\n        // A ends before B does. We have to pull A out of B\n        if (rangeA[1] < rangeB[1]) {\n          overlap = rangeA[1] - rangeB[0];\n          response['bInA'] = false;\n          // B is fully inside A.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n        // B starts further left than A\n      } else {\n        response['bInA'] = false;\n        // B ends before A ends. We have to push A out of B\n        if (rangeA[1] > rangeB[1]) {\n          overlap = rangeA[0] - rangeB[1];\n          response['aInB'] = false;\n          // A is fully inside B.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n      }\n      // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.\n      var absOverlap = Math.abs(overlap);\n      if (absOverlap < response['overlap']) {\n        response['overlap'] = absOverlap;\n        response['overlapN'].copy(axis);\n        if (overlap < 0) {\n          response['overlapN'].reverse();\n        }\n      }\n    }\n    T_VECTORS.push(offsetV);\n    T_ARRAYS.push(rangeA);\n    T_ARRAYS.push(rangeB);\n    return false;\n  }\n  SAT['isSeparatingAxis'] = isSeparatingAxis;\n\n  // Calculates which Voronoi region a point is on a line segment.\n  // It is assumed that both the line and the point are relative to `(0,0)`\n  //\n  //            |       (0)      |\n  //     (-1)  [S]--------------[E]  (1)\n  //            |       (0)      |\n  /**\n   * @param {Vector} line The line segment.\n   * @param {Vector} point The point.\n   * @return  {number} LEFT_VORONOI_REGION (-1) if it is the left region,\n   *          MIDDLE_VORONOI_REGION (0) if it is the middle region,\n   *          RIGHT_VORONOI_REGION (1) if it is the right region.\n   */\n  function voronoiRegion(line, point) {\n    var len2 = line.len2();\n    var dp = point.dot(line);\n    // If the point is beyond the start of the line, it is in the\n    // left voronoi region.\n    if (dp < 0) { return LEFT_VORONOI_REGION; }\n    // If the point is beyond the end of the line, it is in the\n    // right voronoi region.\n    else if (dp > len2) { return RIGHT_VORONOI_REGION; }\n    // Otherwise, it's in the middle one.\n    else { return MIDDLE_VORONOI_REGION; }\n  }\n  // Constants for Voronoi regions\n  /**\n   * @const\n   */\n  var LEFT_VORONOI_REGION = -1;\n  /**\n   * @const\n   */\n  var MIDDLE_VORONOI_REGION = 0;\n  /**\n   * @const\n   */\n  var RIGHT_VORONOI_REGION = 1;\n\n  // ## Collision Tests\n\n  // Check if a point is inside a circle.\n  /**\n   * @param {Vector} p The point to test.\n   * @param {Circle} c The circle to test.\n   * @return {boolean} true if the point is inside the circle, false if it is not.\n   */\n  function pointInCircle(p, c) {\n    var differenceV = T_VECTORS.pop().copy(p).sub(c['pos']).sub(c['offset']);\n    var radiusSq = c['r'] * c['r'];\n    var distanceSq = differenceV.len2();\n    T_VECTORS.push(differenceV);\n    // If the distance between is smaller than the radius then the point is inside the circle.\n    return distanceSq <= radiusSq;\n  }\n  SAT['pointInCircle'] = pointInCircle;\n\n  // Check if a point is inside a convex polygon.\n  /**\n   * @param {Vector} p The point to test.\n   * @param {Polygon} poly The polygon to test.\n   * @return {boolean} true if the point is inside the polygon, false if it is not.\n   */\n  function pointInPolygon(p, poly) {\n    TEST_POINT['pos'].copy(p);\n    T_RESPONSE.clear();\n    var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);\n    if (result) {\n      result = T_RESPONSE['aInB'];\n    }\n    return result;\n  }\n  SAT['pointInPolygon'] = pointInPolygon;\n\n  // Check if two circles collide.\n  /**\n   * @param {Circle} a The first circle.\n   * @param {Circle} b The second circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   the circles intersect.\n   * @return {boolean} true if the circles intersect, false if they don't.\n   */\n  function testCircleCircle(a, b, response) {\n    // Check if the distance between the centers of the two\n    // circles is greater than their combined radius.\n    var differenceV = T_VECTORS.pop().copy(b['pos']).add(b['offset']).sub(a['pos']).sub(a['offset']);\n    var totalRadius = a['r'] + b['r'];\n    var totalRadiusSq = totalRadius * totalRadius;\n    var distanceSq = differenceV.len2();\n    // If the distance is bigger than the combined radius, they don't intersect.\n    if (distanceSq > totalRadiusSq) {\n      T_VECTORS.push(differenceV);\n      return false;\n    }\n    // They intersect.  If we're calculating a response, calculate the overlap.\n    if (response) {\n      var dist = Math.sqrt(distanceSq);\n      response['a'] = a;\n      response['b'] = b;\n      response['overlap'] = totalRadius - dist;\n      response['overlapN'].copy(differenceV.normalize());\n      response['overlapV'].copy(differenceV).scale(response['overlap']);\n      response['aInB'] = a['r'] <= b['r'] && dist <= b['r'] - a['r'];\n      response['bInA'] = b['r'] <= a['r'] && dist <= a['r'] - b['r'];\n    }\n    T_VECTORS.push(differenceV);\n    return true;\n  }\n  SAT['testCircleCircle'] = testCircleCircle;\n\n  // Check if a polygon and a circle collide.\n  /**\n   * @param {Polygon} polygon The polygon.\n   * @param {Circle} circle The circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonCircle(polygon, circle, response) {\n    // Get the position of the circle relative to the polygon.\n    var circlePos = T_VECTORS.pop().copy(circle['pos']).add(circle['offset']).sub(polygon['pos']);\n    var radius = circle['r'];\n    var radius2 = radius * radius;\n    var points = polygon['calcPoints'];\n    var len = points.length;\n    var edge = T_VECTORS.pop();\n    var point = T_VECTORS.pop();\n\n    // For each edge in the polygon:\n    for (var i = 0; i < len; i++) {\n      var next = i === len - 1 ? 0 : i + 1;\n      var prev = i === 0 ? len - 1 : i - 1;\n      var overlap = 0;\n      var overlapN = null;\n\n      // Get the edge.\n      edge.copy(polygon['edges'][i]);\n      // Calculate the center of the circle relative to the starting point of the edge.\n      point.copy(circlePos).sub(points[i]);\n\n      // If the distance between the center of the circle and the point\n      // is bigger than the radius, the polygon is definitely not fully in\n      // the circle.\n      if (response && point.len2() > radius2) {\n        response['aInB'] = false;\n      }\n\n      // Calculate which Voronoi region the center of the circle is in.\n      var region = voronoiRegion(edge, point);\n      // If it's the left region:\n      if (region === LEFT_VORONOI_REGION) {\n        // We need to make sure we're in the RIGHT_VORONOI_REGION of the previous edge.\n        edge.copy(polygon['edges'][prev]);\n        // Calculate the center of the circle relative the starting point of the previous edge\n        var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);\n        region = voronoiRegion(edge, point2);\n        if (region === RIGHT_VORONOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos);\n            T_VECTORS.push(edge);\n            T_VECTORS.push(point);\n            T_VECTORS.push(point2);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n        T_VECTORS.push(point2);\n        // If it's the right region:\n      } else if (region === RIGHT_VORONOI_REGION) {\n        // We need to make sure we're in the left region on the next edge\n        edge.copy(polygon['edges'][next]);\n        // Calculate the center of the circle relative to the starting point of the next edge.\n        point.copy(circlePos).sub(points[next]);\n        region = voronoiRegion(edge, point);\n        if (region === LEFT_VORONOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos);\n            T_VECTORS.push(edge);\n            T_VECTORS.push(point);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n        // Otherwise, it's the middle region:\n      } else {\n        // Need to check if the circle is intersecting the edge,\n        // Change the edge into its \"edge normal\".\n        var normal = edge.perp().normalize();\n        // Find the perpendicular distance between the center of the\n        // circle and the edge.\n        var dist = point.dot(normal);\n        var distAbs = Math.abs(dist);\n        // If the circle is on the outside of the edge, there is no intersection.\n        if (dist > 0 && distAbs > radius) {\n          // No intersection\n          T_VECTORS.push(circlePos);\n          T_VECTORS.push(normal);\n          T_VECTORS.push(point);\n          return false;\n        } else if (response) {\n          // It intersects, calculate the overlap.\n          overlapN = normal;\n          overlap = radius - dist;\n          // If the center of the circle is on the outside of the edge, or part of the\n          // circle is on the outside, the circle is not fully inside the polygon.\n          if (dist >= 0 || overlap < 2 * radius) {\n            response['bInA'] = false;\n          }\n        }\n      }\n\n      // If this is the smallest overlap we've seen, keep it.\n      // (overlapN may be null if the circle was in the wrong Voronoi region).\n      if (overlapN && response && Math.abs(overlap) < Math.abs(response['overlap'])) {\n        response['overlap'] = overlap;\n        response['overlapN'].copy(overlapN);\n      }\n    }\n\n    // Calculate the final overlap vector - based on the smallest overlap.\n    if (response) {\n      response['a'] = polygon;\n      response['b'] = circle;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    T_VECTORS.push(circlePos);\n    T_VECTORS.push(edge);\n    T_VECTORS.push(point);\n    return true;\n  }\n  SAT['testPolygonCircle'] = testPolygonCircle;\n\n  // Check if a circle and a polygon collide.\n  //\n  // **NOTE:** This is slightly less efficient than polygonCircle as it just\n  // runs polygonCircle and reverses everything at the end.\n  /**\n   * @param {Circle} circle The circle.\n   * @param {Polygon} polygon The polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testCirclePolygon(circle, polygon, response) {\n    // Test the polygon against the circle.\n    var result = testPolygonCircle(polygon, circle, response);\n    if (result && response) {\n      // Swap A and B in the response.\n      var a = response['a'];\n      var aInB = response['aInB'];\n      response['overlapN'].reverse();\n      response['overlapV'].reverse();\n      response['a'] = response['b'];\n      response['b'] = a;\n      response['aInB'] = response['bInA'];\n      response['bInA'] = aInB;\n    }\n    return result;\n  }\n  SAT['testCirclePolygon'] = testCirclePolygon;\n\n  // Checks whether polygons collide.\n  /**\n   * @param {Polygon} a The first polygon.\n   * @param {Polygon} b The second polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonPolygon(a, b, response) {\n    var aPoints = a['calcPoints'];\n    var aLen = aPoints.length;\n    var bPoints = b['calcPoints'];\n    var bLen = bPoints.length;\n    // If any of the edge normals of A is a separating axis, no intersection.\n    for (var i = 0; i < aLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, a['normals'][i], response)) {\n        return false;\n      }\n    }\n    // If any of the edge normals of B is a separating axis, no intersection.\n    for (var i = 0; i < bLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, b['normals'][i], response)) {\n        return false;\n      }\n    }\n    // Since none of the edge normals of A or B are a separating axis, there is an intersection\n    // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the\n    // final overlap vector.\n    if (response) {\n      response['a'] = a;\n      response['b'] = b;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    return true;\n  }\n  SAT['testPolygonPolygon'] = testPolygonPolygon;\n\n  return SAT;\n}));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}